<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Java并发包 | 世界で一番おひめさま</title><meta name="description" content="Java并发包"><meta name="keywords" content="Java,,并发"><meta name="author" content="Cqz"><meta name="copyright" content="Cqz"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java并发包"><meta name="twitter:description" content="Java并发包"><meta name="twitter:image" content="https://mega-cqz.github.io/img/Fate.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java并发包"><meta property="og:url" content="https://mega-cqz.github.io/2020/03/01/JUC/"><meta property="og:site_name" content="世界で一番おひめさま"><meta property="og:description" content="Java并发包"><meta property="og:image" content="https://mega-cqz.github.io/img/Fate.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://mega-cqz.github.io/2020/03/01/JUC/"><link rel="prev" title="特征工程" href="https://mega-cqz.github.io/2020/03/02/feature/"><link rel="next" title="Java" href="https://mega-cqz.github.io/2020/03/01/Java/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">世界で一番おひめさま</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/%E9%BB%84%E6%BC%AB%E8%80%81%E5%B8%88.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#阻塞队列"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">阻塞队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ArrayBlockingQueue"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">ArrayBlockingQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#LinkedBlockingQueue"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">LinkedBlockingQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#DelayQueue"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">DelayQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#SynchronousQueue"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">SynchronousQueue</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#并发锁"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">并发锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ConcurrentHashMap"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">ConcurrentHashMap</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#sizeCtl"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">sizeCtl</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#判断是否需要扩容"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">判断是否需要扩容</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Transfer："><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">Transfer：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Size（）方法"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">Size（）方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ConcurrentLinkedQueue"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">ConcurrentLinkedQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#CopyOnWriteArrayList"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">CopyOnWriteArrayList</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#CopyOnWriteArray-Set"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">CopyOnWriteArray Set</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ConcurrentSkipListMap"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">ConcurrentSkipListMap</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ConcurrentSkipListSet"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">ConcurrentSkipListSet</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#AtomicBoolean"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">AtomicBoolean</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#AtomicStampedReference"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">AtomicStampedReference</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#LongAdder"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">LongAdder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#并发工具"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">并发工具</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Semaphore"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text">Semaphore</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Phaser"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text">Phaser</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CountDownLatch"><span class="toc_mobile_items-number">12.3.</span> <span class="toc_mobile_items-text">CountDownLatch</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CyclicBarrier"><span class="toc_mobile_items-number">12.4.</span> <span class="toc_mobile_items-text">CyclicBarrier</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Exchanger"><span class="toc_mobile_items-number">12.5.</span> <span class="toc_mobile_items-text">Exchanger</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#AQS"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">AQS</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ReentrantReadWriteLock"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">ReentrantReadWriteLock</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#阻塞队列"><span class="toc-number">1.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">1.1.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">1.2.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DelayQueue"><span class="toc-number">1.3.</span> <span class="toc-text">DelayQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">1.4.</span> <span class="toc-text">SynchronousQueue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发锁"><span class="toc-number">2.</span> <span class="toc-text">并发锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">3.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeCtl"><span class="toc-number">3.1.</span> <span class="toc-text">sizeCtl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断是否需要扩容"><span class="toc-number">3.2.</span> <span class="toc-text">判断是否需要扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transfer："><span class="toc-number">3.3.</span> <span class="toc-text">Transfer：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Size（）方法"><span class="toc-number">3.4.</span> <span class="toc-text">Size（）方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">4.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">5.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CopyOnWriteArray-Set"><span class="toc-number">6.</span> <span class="toc-text">CopyOnWriteArray Set</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentSkipListMap"><span class="toc-number">7.</span> <span class="toc-text">ConcurrentSkipListMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentSkipListSet"><span class="toc-number">8.</span> <span class="toc-text">ConcurrentSkipListSet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AtomicBoolean"><span class="toc-number">9.</span> <span class="toc-text">AtomicBoolean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-number">10.</span> <span class="toc-text">AtomicStampedReference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LongAdder"><span class="toc-number">11.</span> <span class="toc-text">LongAdder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发工具"><span class="toc-number">12.</span> <span class="toc-text">并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number">12.1.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Phaser"><span class="toc-number">12.2.</span> <span class="toc-text">Phaser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">12.3.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">12.4.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exchanger"><span class="toc-number">12.5.</span> <span class="toc-text">Exchanger</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS"><span class="toc-number">13.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">14.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/Fate.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Java并发包</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-03-01<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-04</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>底层是基于数组实现的队列。定长。插入元素和取出元素的方法共用同行一个锁，也就是存取操作无法并行。创建时可以选择对象的内部锁是否为公平锁，默认为非公平锁。<br>加入Condition来判断队列是否够大，或者是否有值<br>判断队列中有无元素或者满不满。重入锁实现ReentrantLock<br>（1）利用数组存储元素；<br>（2）通过放指针和取指针来标记下一次操作的位置；<br>（3）利用重入锁来保证并发安全；<br>入队：（1）add(e)时如果队列满了则抛出异常；<br>（2）offer(e)时如果队列满了则返回false；<br>（3）put(e)时如果队列满了则使用notFull等待；<br>（4）offer(e, timeout, unit)时如果队列满了则等待一段时间后如果队列依然满就返回false；<br>（5）利用放指针循环使用数组来存储元素；</p>
<p>出队：<br>（1）remove()时如果队列为空则抛出异常；<br>（2）poll()时如果队列为空则返回null；<br>（3）take()时如果队列为空则阻塞等待在条件notEmpty上；<br>（4）poll(timeout, unit)时如果队列为空则阻塞等待一段时间后如果还为空就返回null；<br>（5）利用取指针循环从数组中取元素；<br>（1）ArrayBlockingQueue不需要扩容，因为是初始化时指定容量，并循环利用数组；<br>（2）ArrayBlockingQueue利用takeIndex和putIndex循环利用数组；<br>（3）入队和出队各定义了四组方法为满足不同的用途；<br>（4）利用重入锁和两个条件保证并发安全；<br>ArrayBlockingQueue有哪些缺点呢？<br>a）队列长度固定且必须在初始化时指定，所以使用之前一定要慎重考虑好容量；<br>b）如果消费速度跟不上入队速度，则会导致提供者线程一直阻塞，且越阻塞越多，非常危险；<br>c）只使用了一个锁来控制入队出队，效率较低</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>底层是基于链表实现的队列。可以指定最大缓存容量。插入元素的方法和取出元素的方法采用独立的锁，高并发状态下生产者和消费者可以并行地操作队列中的数据。作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。<br>（1）capacity，有容量，可以理解为LinkedBlockingQueue是有界队列<br>（2）head, last，链表头、链表尾指针<br>（3）takeLock，notEmpty，take锁及其对应的条件<br>（4）putLock, notFull，put锁及其对应的条件<br>（5）入队、出队使用两个不同的锁控制，锁分离，提高效率<br>总结<br>（1）LinkedBlockingQueue采用单链表的形式实现；<br>（2）LinkedBlockingQueue采用两把锁的锁分离技术实现入队出队互不阻塞；<br>（3）LinkedBlockingQueue是有界队列，不传入容量时默认为最大int值；<br>彩蛋<br>（1）LinkedBlockingQueue与ArrayBlockingQueue对比？<br>a）后者入队出队采用一把锁，导致入队出队相互阻塞，效率低下；<br>b）前才入队出队采用两把锁，入队出队互不干扰，效率较高；<br>c）二者都是有界队列，如果长度相等且出队速度跟不上入队速度，都会导致大量线程阻塞；<br>d）前者如果初始化不传入初始容量，则使用最大int值，如果出队速度跟不上入队速度，会导致队列特别长，占用大量内存；</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>•  PriorityBlockingQueue<br>（1）依然是使用一个数组来使用元素；<br>（2）使用一个锁加一个notEmpty条件来保证并发安全；<br>（3）使用一个变量的CAS操作来控制扩容；<br>入队的整个操作跟PriorityQueue几乎一致：<br>（1）加锁；<br>（2）判断是否需要扩容；<br>（3）添加元素并做自下而上的堆化；<br>（4）元素个数加1并唤醒notEmpty条件，唤醒取元素的线程；<br>（5）解锁；<br>扩容<br>（1）解锁，解除offer()方法中加的锁；<br>（2）使用allocationSpinLock变量的CAS操作来控制扩容的过程；<br>（3）旧容量小于64则翻倍，旧容量大于64则增加一半；<br>（4）创建新数组；<br>（5）修改allocationSpinLock为0，相当于解锁；<br>（6）其它线程在扩容的过程中要让出CPU；<br>（7）再次加锁；<br>（8）新数组创建成功，把旧数组元素拷贝过来，并返回到offer()方法中继续添加元素操作；</p>
<p>（1）PriorityBlockingQueue整个入队出队的过程与PriorityQueue基本是保持一致的；<br>（2）PriorityBlockingQueue使用一个锁+一个notEmpty条件控制并发安全；<br>（3）PriorityBlockingQueue扩容时使用一个单独变量的CAS操作来控制只有一个线程进行扩容；<br>（4）入队使用自下而上的堆化；<br>（5）出队使用自上而下的堆化；</p>
<p>带有优先级的队列，元素按照他们的优先级顺序被移出。容量没有上线，不会阻塞插入元素的方法，会阻塞取出元素的方法。公平锁。 </p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>一种无缓冲的等待队列。<br>（1）这个阻塞队列里面是会自旋的；<br>（2）它使用了一个叫做transferer的东西来交换元素；<br>（1）SynchronousQueue是java里的无缓冲队列，用于在两个线程之间直接移交元素；<br>（2）SynchronousQueue有两种实现方式，一种是公平（队列）方式，一种是非公平（栈）方式；<br>（3）栈方式中的节点有三种模式：生产者、消费者、正在匹配中；<br>（4）栈方式的大致思路是如果栈顶元素跟自己一样的模式就入栈并等待被匹配，否则就匹配，匹配到了就返回；<br>（5）队列方式的大致思路是……不告诉你^^（两者的逻辑差别还是挺大的）</p>
<h1 id="并发锁"><a href="#并发锁" class="headerlink" title="并发锁"></a>并发锁</h1><p>ReentrantReadWriteLock<br>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过AQS来实现的<br>AQS定义了独占模式的acquire()和release()方法，共享模式的acquireShared()和releaseShared()方法.还定义了抽象方法tryAcquire()、tryAcquiredShared()、tryRelease()和tryReleaseShared()由子类实现，tryAcquire()和tryAcquiredShared()分别对应独占模式和共享模式下的锁的尝试获取，就是通过这两个方法来实现公平性和非公平性，在尝试获取中，如果新来的线程必须先入队才能获取锁就是公平的，否则就是非公平的。这里可以看出AQS定义整体的同步器框架，具体实现放手交由子类实现。<br>核心其实就是实现读写分离。在高并发的情况下，尤其是读多写少的情况下，性能远高于重入锁<br>之前的ReentrantLock和synchronized的使用时，同一时间内，只能一个线程访问被锁定的代码。读写锁不同，其本质是2个锁，即读锁和写锁。在读锁下，多个线程可以并发访问，但是在写锁下，只能串行访问<br>口诀：读读共享，写写互斥，读写互斥<br>AQS 的状态state是32位（int 类型）的，辦成两份，读锁用高16位，表示持有读锁的线程数（sharedCount），写锁低16位，表示写锁的重入次数 （exclusiveCount）。状态值为 0 表示锁空闲，sharedCount不为 0 表示分配了读锁，exclusiveCount 不为 0 表示分配了写锁，sharedCount和exclusiveCount 一般不会同时不为 0，只有当线程占用了写锁，该线程可以重入获取读锁，反之不成立。<br>（1）首先说一下公平锁和非公平锁的区别，<br>公平锁：当线程发现已经有线程在排对获取锁了，那么它必须排队，除了一种情况就是，线程已经占有锁，此次是重入，不用排队。<br>非公平锁：只有一种情况需排队，其他情况不用排队就可以尝试获取锁： 如果当前全局处于读锁状态，且等待队列中第一个等待线程想获取写锁，那么当前线程能够获取到读锁的条件为：当前线程获取了写锁，还未释放；当前线程获取了读锁，这一次只是重入读锁而已；其它情况当前线程入队尾。<br>（2）获取读锁和释放读锁<br>获取锁的过程：<br>    当线程调用acquireShared()申请获取锁资源时，如果成功，则进入临界区。<br>    当获取锁失败时，则创建一个共享类型的节点并进入一个FIFO等待队列，然后被挂起等待唤醒。<br>    当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点，然后进入临界区，否则继续挂起等待。<br>释放锁过程：<br>    当线程调用releaseShared()进行锁资源释放时，如果释放成功，则唤醒队列中等待的节点，如果有的话。<br>（3）跟独占锁相比，共享锁的主要特征在于当一个在等待队列中的共享节点成功获取到锁以后（它获取到的是共享锁），既然是共享，那它必须要依次唤醒后面所有可以跟它一起共享当前锁资源的节点，毫无疑问，这些节点必须也是在等待共享锁（这是大前提，如果等待的是独占锁，那前面已经有一个共享节点获取锁了，它肯定是获取不到的）。当共享锁被释放的时候，可以用读写锁为例进行思考，当一个读锁被释放，此时不论是读锁还是写锁都是可以竞争资源的。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><ol>
<li>table：默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。</li>
<li>nextTable：默认为null，扩容时新生成的数组，其大小为原数组的两倍。<h2 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h2>默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。<br>•    -1 代表table正在初始化<br>•    -N 表示有N-1个线程正在进行扩容操作<br>•    其余情况：<br>1、如果table未初始化，表示table需要初始化的大小。<br>2、如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n >>> 2)）。<br>实例化ConcurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，</li>
</ol>
<p>构造方法与HashMap对比可以发现，没有了HashMap中的threshold和loadFactor，而是改用了sizeCtl来控制，而且只存储了容量在里面，那么它是怎么用的呢？官方给出的解释如下：<br>（1）-1，表示有线程正在进行初始化操作<br>（2）-(1 + nThreads)，表示有n个线程正在一起扩容<br>（3）0，默认值，后续在真正初始化的时候使用默认容量<br>（4）> 0，初始化或扩容完成后下一次的扩容门槛<br>（1）如果桶数组未初始化，则初始化；<br>（2）如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；<br>（3）如果正在扩容，则当前线程一起加入到扩容的过程中；<br>（4）如果待插入的元素所在的桶不为空且不在迁移元素，则锁住这个桶（分段锁）；<br>（5）如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；<br>（6）如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；<br>（7）如果元素存在，则返回旧值；<br>（8）如果元素不存在，整个Map的元素个数加1，并检查是否需要扩容；<br>添加元素操作中使用的锁主要有（自旋锁 + CAS + synchronized + 分段锁）。</p>
<h2 id="判断是否需要扩容"><a href="#判断是否需要扩容" class="headerlink" title="判断是否需要扩容"></a>判断是否需要扩容</h2><p>每次添加元素后，元素数量加1，并判断是否达到扩容门槛，达到了则进行扩容或协助扩容。<br>（1）元素个数的存储方式类似于LongAdder类，存储在不同的段上，减少不同线程同时更新size时的冲突；<br>（2）计算元素个数时把这些段的值及baseCount相加算出总的元素个数；<br>（3）正常情况下sizeCtl存储着扩容门槛，扩容门槛为容量的0.75倍；<br>（4）扩容时sizeCtl高位存储扩容邮戳(resizeStamp)，低位存储扩容线程数加1（1+nThreads）；<br>（5）其它线程添加元素后如果发现存在扩容，也会加入的扩容行列中来；</p>
<h2 id="Transfer："><a href="#Transfer：" class="headerlink" title="Transfer："></a>Transfer：</h2><p>（1）新桶数组大小是旧桶数组的两倍；<br>（2）迁移元素先从靠后的桶开始；<br>（3）迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成；<br>（4）迁移时根据hash&n是否等于0把桶中元素分化成两个链表或树；<br>（5）低位链表（树）存储在原来的位置；<br>（6）高们链表（树）存储在原来的位置加n的位置；<br>（7）迁移元素时会锁住当前桶，也是分段锁的思想；</p>
<p>1.8其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。<br>有红黑树<br>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。默认情况下此时的<br>CAS设置值取值返回节点位置时用<br>ConcurrentHashMap支持16个线程并发操作。PutVal通过synchronized来加锁<br>扩容也是synchronized<br>2倍扩容<br>ConcurrentHashMap是如何解决HashMap并发问题这一疑问进行简要说明。<br>•    首先new一个新的hash表(nextTable)出来，大小是原来的2倍。后面的rehash都是针对这个新的hash表操作，不涉及原hash表(table)。<br>•    然后会对原hash表(table)中的每个链表进行rehash，此时会尝试获取头节点的锁。这一步就保证了在rehash的过程中不能对这个链表执行put操作。<br>•    通过sizeCtl控制，使扩容过程中不会new出多个新hash表来。<br>•    最后，将所有键值对重新rehash到新表(nextTable)中后，用nextTable将table替换。这就避免了HashMap中get和扩容并发时，可能get到null的问题。<br>•    在整个过程中，共享变量的存储和读取全部通过volatile或CAS的方式，保证了线程安全。<br>总结<br>（1）ConcurrentHashMap是HashMap的线程安全版本；<br>（2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；<br>（3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；<br>（4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；<br>（5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；<br>（6）sizeCtl = -1，表示正在进行初始化；<br>（7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；<br>（8）sizeCtl > 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；<br>（9）sizeCtl = (resizeStamp << 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；<br>（10）更新操作时如果正在进行扩容，当前线程协助扩容；<br>（11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；<br>（12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；<br>（13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；<br>（14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；<br>（15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；<br>（16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；<br>（17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；<br>（18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；<br>（19）ConcurrentHashMap中不能存储key或value为null的元素；</p>
<h2 id="Size（）方法"><a href="#Size（）方法" class="headerlink" title="Size（）方法"></a>Size（）方法</h2><p>在 JDK1.7 中，第一种方案他会使用不加锁的模式去尝试多次计算 ConcurrentHashMap 的 size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。 第二种方案是如果第一种方案不符合，他就会给每个 Segment 加上锁，然后计算 ConcurrentHashMap 的 size 返回。<br>1.8：size()，最大值是 Integer 类型的最大值，但是 Map 的 size 可能超过 MAX_VALUE， 所以还有一个方法 mappingCount()，JDK 的建议使用 mappingCount() 而不是size()。无论是 size() 还是 mappingCount(), 计算大小的核心方法都是 sumCount()。JDK1.8 size 是通过对 baseCount 和 counterCell 进行 CAS 计算，最终通过 baseCount 和 遍历 CounterCell 数组得出 size。<br>在没有并发的情况下，使用一个 baseCount volatile 变量就足够了，当并发的时候，CAS 修改 baseCount 失败后，就会使用 CounterCell 类了，会创建一个这个对象，通常对象的 volatile value 属性是 1。在计算 size 的时候，会将 baseCount 和 CounterCell 数组中的元素的 value 累加，得到总的大小，但这个数字仍旧可能是不准确的。<br>还有一个需要注意的地方就是，这个 CounterCell 类使用了 @sun.misc.Contended 注解标识，这个注解是防止伪共享的。是 1.8 新增的。使用时，需要加上 -XX:-RestrictContended 参数。<br>1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount<br>初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，使用CounterCell记录元素个数的变化；<br>2、如果CounterCell数组counterCells为空，调用fullAddCount()方法进行初始化，并插入对应的记录数，通过CAS设置cellsBusy字段，只有设置成功的线程才能初始化CounterCell数组，实现如下：<br>如果通过CAS设置cellsBusy字段失败的话，则继续尝试通过CAS修改baseCount字段，如果修改baseCount字段成功的话，就退出循环，否则继续循环插入CounterCell对象；<br>1.8中的size实现比1.7简单多，因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中<br>两个数组分别保存相加。</p>
<h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p>从源代码角度来看整个入队过程主要做两件事情：</p>
<p>  第一是定位出尾节点<br>  第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<p>第一步定位尾节点。tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于q节点的情况，出现这种情况的原因我们后续再来介绍。</p>
<p>第二步设置入队节点为尾节点。p.casNext(null, newNode)方法用于将入队节点设置为当前队列尾节点的next节点，q如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p>
<p>ConcurrentLinkedQueue 的非阻塞算法实现可概括为下面 5 点：</p>
<p>   使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。<br>    head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。<br>    由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 使用三个不变式来维护非阻塞算法的正确性。<br>    以批处理方式来更新 head/tail，从整体上减少入队 / 出队操作的开销。<br>为了有利于垃圾收集，队列使用特有的 head 更新机制；为了确保从已删除节点向后遍历，可到达所有的非删除节点，队列使用了特有的向后推进策略。<br>ConcurrentLinkedQueue 底层使用单向链表数据结构来保存队列元素，每个元素被包装为了一个 Node 节点，队列是靠头尾节点来维护的，创建队列时候头尾节点指向一个 item 为 null 的哨兵节点，<br>第一次    peek 或者 first 时候会把 head 指向第一个真正的队列元素。由于使用非阻塞 CAS 算法，没有加锁，所以获取 size 的时候有可能进行了 offer，poll 或者 remove 操作，导致获取的元素个数不精确，所以在并发情况下 size 函数不是很有用。</p>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>CopyOnWriteArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。<br>CopyOnWriteArrayList实现了List，提供了基础的添加、删除、遍历等操作。<br>CopyOnWriteArrayList实现了RandomAccess，提供了随机访问的能力。<br>CopyOnWriteArrayList实现了Cloneable，可以被克隆。<br>CopyOnWriteArrayList实现了Serializable，可以被序列化。</p>
<p>（1）CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全；<br>（2）CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能比较低下；<br>（3）CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)；<br>（4）CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；<br>（5）CopyOnWriteArrayList只保证最终一致性，不保证实时一致性；</p>
<h1 id="CopyOnWriteArray-Set"><a href="#CopyOnWriteArray-Set" class="headerlink" title="CopyOnWriteArray Set"></a>CopyOnWriteArray Set</h1><p>CopyOnWriteArraySet底层是使用CopyOnWriteArrayList存储元素的，所以它并不是使用Map来存储元素的。<br>（1）CopyOnWriteArraySet是用CopyOnWriteArrayList实现的；<br>（2）CopyOnWriteArraySet是有序的，因为底层其实是数组，数组是不是有序的？！<br>（3）CopyOnWriteArraySet是并发安全的，而且实现了读写分离；<br>（4）CopyOnWriteArraySet通过调用CopyOnWriteArrayList的addIfAbsent()方法来保证元素不重复；</p>
<h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h1><p>插入过程分成三个部分：<br>Part I：找到目标节点的位置并插入<br>（1）这里的目标节点是数据节点，也就是最底层的那条链；<br>（2）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；<br>（3）从这个数据节点开始往后遍历，直到找到目标节点应该插入的位置；<br>（4）如果这个位置有元素，就更新其值（onlyIfAbsent=false）；<br>（5）如果这个位置没有元素，就把目标节点插入；<br>（6）至此，目标节点已经插入到最底层的数据节点链表中了；<br>Part II：随机决定是否需要建立索引及其层次，如果需要则建立自上而下的索引<br>（1）取个随机数rnd，计算(rnd & 0x80000001)；<br>（2）如果不等于0，结束插入过程，也就是不需要创建索引，返回；<br>（3）如果等于0，才进入创建索引的过程（只要正偶数才会等于0）；<br>（4）计算while (((rnd >>>= 1) & 1) != 0)，决定层级数，level从1开始；<br>（5）如果算出来的层级不高于现有最高层级，则直接建立一条竖直的索引链表（只有down有值），并结束Part II；<br>（6）如果算出来的层级高于现有最高层级，则新的层级只能比现有最高层级多1；<br>（7）同样建立一条竖直的索引链表（只有down有值）；<br>（8）将头索引也向上增加到相应的高度，结束Part II；<br>（9）也就是说，如果层级不超过现有高度，只建立一条索引链，否则还要额外增加头索引链的高度（脑补一下，后面举例说明）；<br>Part III：将新建的索引节点（包含头索引节点）与其它索引节点通过右指针连接在一起（补上right指针）<br>（1）从最高层级的头索引节点开始，向右遍历，找到目标索引节点的位置；<br>（2）如果当前层有目标索引，则把目标索引插入到这个位置，并把目标索引前一个索引向下移一个层级；<br>（3）如果当前层没有目标索引，则把目标索引位置前一个索引向下移一个层级；<br>（4）同样地，再向右遍历，寻找新的层级中目标索引的位置，回到第（2）步；<br>（5）依次循环找到所有层级目标索引的位置并把它们插入到横向的索引链表中；<br>总结起来，一共就是三大步：<br>（1）插入目标节点到数据节点链表中；<br>（2）建立竖直的down链表；<br>（3）建立横向的right链表；<br>CAS</p>
<h1 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h1><p>底层是通过ConcurrentSkipListMap、ConcurrentNavigableMap，是一个有序的线程安全的集合。<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583308374195.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583308374195.png" class="lazyload"></a><br>List可重复，set不可重复，Map键值对<br>（1）ConcurrentSkipListSet底层是使用ConcurrentNavigableMap实现的；<br>（2）ConcurrentSkipListSet有序的，基于元素的自然排序或者通过比较器确定的顺序；<br>（3）ConcurrentSkipListSet是线程安全的；</p>
<h1 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h1><p>由此可见，原子类底层使用的是unsafe类的CAS来控制原子操作的，如果CAS失败则一直尝试。而且value使用volatile保证多线程可见性。<br>（1）AtomicInteger中维护了一个使用volatile修饰的变量value，保证可见性；<br>（2）AtomicInteger中的主要方法最终几乎都会调用到Unsafe的compareAndSwapInt()方法保证对变量修改的原子性。</p>
<h1 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h1><p>ABA的危害我们清楚了，那么怎么解决ABA呢？<br>笔者总结了一下，大概有以下几种方式：<br>（1）版本号<br>比如，上面的栈结构增加一个版本号用于控制，每次CAS的同时检查版本号有没有变过。<br>还有一些数据结构喜欢使用高位存储一个邮戳来保证CAS的安全。<br>（2）不重复使用节点的引用<br>比如，上面的栈结构在线程2执行push()入栈操作的时候新建一个节点传入，而不是复用节点1的引用；<br>（3）直接操作元素而不是节点<br>比如，上面的栈结构push()方法不应该传入一个节点（Node），而是传入元素值（int的value）。<br>首先，使用版本号控制；<br>其次，不重复使用节点（Pair）的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的；<br>最后，外部传入元素值及版本号，而不是节点（Pair）的引用。</p>
<h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p>累加方法<br>唯一会制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高， 重试次数更多，越多线程重试，CAS失败几率又越高，变成恶性循环，AtomicLong效率降低。 那怎么解决？ LongAdder给了我们一个非常容易想到的解决方案：减少并发，将单一value的更新压力分担到多个value中去，降低单个value的 “热度”，分段更新！！！<br>这样，线程数再多也会分担到多个value上去更新，只需要增加value就可以降低 value的 “热度” AtomicLong中的 恶性循环不就解决了吗？ cells 就是这个 “段” cell中的value 就是存放更新值的， 这样，当我需要总数时，把cells 中的value都累加一下不就可以了么！！<br>在看看add()方法中的代码，casBase()方法可不可以不要，直接分段更新,上来就计算 索引位置，然后更新value？<br>不是不行，而是有所考虑的,因为，casBase()操作等价于AtomicLong中的CAS操作，要知道，LongAdder这样的处理方式是有坏处的，分段操作必然带来空间上的浪费，可以空间换时间，但是，能不换就不换，空间时间都节约.<br>casBase()操作保证了在低并发时，不会立即进入分支做分段更新操作，因为低并发时，casBase()操作基本都会成功，只有并发高到一定程度了，才会进入分支</p>
<h1 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h1><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>共享锁 AQS实现 tryAcquired<br>Semaphore是JUC包提供的一个共享锁，一般称之为信号量。<br>Semaphore通过自定义的同步器维护了一个或多个共享资源，线程通过调用acquire获取共享资源，通过调用release释放。<br>Semaphore是JUC包提供的一个典型的共享锁，它通过自定义两种不同的同步器（FairSync&NonfairSync）提供了公平&非公平两种工作模式，两种模式下分别提供了限时/不限时、响应中断/不响应中断的获取资源的方法（限时获取总是及时响应中断的），而所有的释放资源的release操作是统一的。<br>Semaphore，信号量，它保存了一系列的许可（permits），每次调用acquire()都将消耗一个许可，每次调用release()都将归还一个许可。<br>（1）许可是在构造方法时传入的；<br>（2）许可存放在状态变量state中；<br>（3）尝试获取一个许可的时候，则state的值减1；<br>（4）当state的值为0的时候，则无法再获取许可；<br>（5）释放一个许可的时候，则state的值加1；<br>（6）许可的个数可以动态改变；</p>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>灵活性的角度来说Phaser>CyclicBarrier>CountDownLatch<br>Phaser，翻译为阶段，它适用于这样一种场景，一个大任务可以分为多个阶段完成，且每个阶段的任务可以多个线程并发执行，但是必须上一个阶段的任务都完成了才可以执行下一个阶段的任务。<br>这种场景虽然使用CyclicBarrier或者CountryDownLatch也可以实现，但是要复杂的多。首先，具体需要多少个阶段是可能会变的，其次，每个阶段的任务数也可能会变的。相比于CyclicBarrier和CountDownLatch，Phaser更加灵活更加方便。<br>（1）Phaser适用于多阶段多任务的场景，每个阶段的任务都可以控制得很细；<br>（2）Phaser内部使用state变量及队列实现整个逻辑<br>（3）state的高32位存储当前阶段phase，中16位存储当前阶段参与者（任务）的数量parties，低16位存储未完成参与者的数量unarrived；<br>（4）队列会根据当前阶段的奇偶性选择不同的队列；<br>（5）当不是最后一个参与者到达时，会自旋或者进入队列排队来等待所有参与者完成任务；<br>（6）当最后一个参与者完成任务时，会唤醒队列中的线程并进入下一个阶段；</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>共享锁<br>CountDownLatch，可以翻译为倒计时器，但是似乎不太准确，它的含义是允许一个或多个线程等待其它线程的操作执行完毕后再执行后续的操作。<br>总结<br>（1）CountDownLatch表示允许一个或多个线程等待其它线程的操作执行完毕后再执行后续的操作；<br>（2）CountDownLatch使用AQS的共享锁机制实现；<br>（3）CountDownLatch初始化的时候需要传入次数count；<br>（4）每次调用countDown()方法count的次数减1；<br>（5）每次调用await()方法的时候会尝试获取锁，这里的获取锁其实是检查AQS的state变量的值是否为0；<br>（6）当count的值（也就是state的值）减为0的时候会唤醒排队着的线程（这些线程调用await()进入队列）；</p>
<p>CountDownLatch中只包含了Sync一个内部类，它没有公平/非公平模式，所以它算是一个比较简单的同步器了。<br>这里还要注意一点，CountDownLatch没有实现Serializable接口，所以它不是可序列化的。<br>（1）CountDownLatch的初始次数是否可以调整？<br>答：前面我们学习Semaphore的时候发现，它的许可次数是可以随时调整的，那么，CountDownLatch的初始次数能随时调整吗？答案是不能的，它没有提供修改（增加或减少）次数的方法，除非使用反射作弊。<br>（2）CountDownLatch为什么使用共享锁？<br>答：前面我们分析ReentrantReadWriteLock的时候学习过AQS的共享锁模式，比如当前锁是由一个线程获取为互斥锁，那么这时候所有需要获取共享锁的线程都要进入AQS队列中进行排队，当这个互斥锁释放的时候，会一个接着一个地唤醒这些连续的排队的等待获取共享锁的线程，注意，这里的用语是“一个接着一个地唤醒”，也就是说这些等待获取共享锁的线程不是一次性唤醒的。<br>说到这里，是不是很明白了？因为CountDownLatch的await()多个线程可以调用多次，当调用多次的时候这些线程都要进入AQS队列中排队，当count次数减为0的时候，它们都需要被唤醒，继续执行任务，如果使用互斥锁则不行，互斥锁在多个线程之间是互斥的，一次只能唤醒一个，不能保证当count减为0的时候这些调用了await()方法等待的线程都被唤醒。<br>（3）CountDownLatch与Thread.join()有何不同？<br>答：Thread.join()是在主线程中调用的，它只能等待被调用的线程结束了才会通知主线程，而CountDownLatch则不同，它的countDown()方法可以在线程执行的任意时刻调用，灵活性更大</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier，回环栅栏，它会阻塞一组线程直到这些线程同时达到某个条件才继续执行。它与CountDownLatch很类似，但又不同，CountDownLatch需要调用countDown()方法触发事件，而CyclicBarrier不需要，它就像一个栅栏一样，当一组线程都到达了栅栏处才继续往下走。<br>（1）CyclicBarrier会使一组线程阻塞在await()处，当最后一个线程到达时唤醒（只是从条件队列转移到AQS队列中）前面的线程大家再继续往下走；<br>（2）CyclicBarrier不是直接使用AQS实现的一个同步器；<br>（3）CyclicBarrier基于ReentrantLock及其Condition实现整个同步逻辑；<br>CyclicBarrier与CountDownLatch的异同？<br>（1）两者都能实现阻塞一组线程等待被唤醒；<br>（2）前者是最后一个线程到达时自动唤醒；<br>（3）后者是通过显式地调用countDown()实现的；<br>（4）前者是通过重入锁及其条件锁实现821的，后者是直接基于AQS实现的；<br>（5）前者具有“代”的概念，可以重复使用，循环使用，后者只能使用一次；<br>（6）前者只能实现多个线程到达栅栏处一起运行；<br>（7）后者不仅可以实现多个线程等待一个线程条件成立，还能实现一个线程等待多个线程条件成立（详见CountDownLatch那章使用案例）；<br>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行<br>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务<br>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用Exchanger的重点是成对的线程使用exchange()方法，当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是成对的。<br>       Exchanger类提供了两个方法，String exchange(V x):用于交换，启动交换并等待另一个线程调用exchange；String exchange(V x,long timeout,TimeUnit unit)：用于交换，启动交换并等待另一个线程调用exchange，并且设置最大等待时间，当等待时间超过timeout便停止等待。</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS中定义了一个状态变量state，它有以下两种使用方法：<br>（1）互斥锁<br>当AQS只实现为互斥锁的时候，每次只要原子更新state的值从0变为1成功了就获取了锁，可重入是通过不断把state原子更新加1实现的。<br>（2）互斥锁 + 共享锁<br>当AQS需要同时实现为互斥锁+共享锁的时候，低16位存储互斥锁的状态，高16位存储共享锁的状态，主要用于实现读写锁。<br>互斥锁是一种独占锁，每次只允许一个线程独占，且当一个线程独占时，其它线程将无法再获取互斥锁及共享锁，但是它自己可以获取共享锁。<br>共享锁同时允许多个线程占有，只要有一个线程占有了共享锁，所有线程（包括自己）都将无法再获取互斥锁，但是可以获取共享锁。<br>AQS中还有另一个非常重要的内部类ConditionObject，它实现了Condition接口，主要用于实现条件锁。<br>ConditionObject中也维护了一个队列，这个队列主要用于等待条件的成立，当条件成立时，其它线程将signal这个队列中的元素，将其移动到AQS的队列中，等待占有锁的线程释放锁后被唤醒。<br>Condition典型的运用场景是在BlockingQueue中的实现，当队列为空时，获取元素的线程阻塞在notEmpty条件上，一旦队列中添加了一个元素，将通知notEmpty条件，将其队列中的元素移动到AQS队列中等待被唤醒。<br>AQS这个抽象类把模板方法设计模式运用地炉火纯青，它里面定义了一系列的模板方法<br>AbstractQueuedSynchronizer（AQS）是一个同步器框架，在实现锁的时候，一般会实现一个继承自AQS的内部类sync，作为我们的自定义同步器。AQS内部维护了一个state成员和一个队列。其中state标识了共享资源的状态，队列则记录了等待资源的线程。以下这五个方法，在AQS中实现为直接抛出异常，这是我们自定义同步器需要重写的方法：<br>①isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>②tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败返回false。<br>③tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败返回false。<br>④tryAcquireShared(int)：共享方式。尝试获取资源。成功返回true，失败返回false。<br>⑤tryReleaseShared(int)：共享方式。尝试释放资源，成功则返回true，失败返回false。<br>它首先调用tryAquire去获取共享资源，如果失败，调用addWaiter将当前线程放入等待队列，返回持有当前线程的Node对象，然后调用acquireQueued方法来监视等待队列并获取资源。acquireQueued方法会阻塞，直到成功获取。注意，acquire方法不能及时响应中断，只能在成功获取锁之后，再来处理。中断当前线程的操作跑出的异常在acquireQueued方法中被捕获，外部调用者没能看到这个异常，因此调用selfInterrupt来重置中断标识。<br>addWaiter首先将当前线程包装在一个Node对象node中，然后获取了一下队列的尾节点，如果队列不为空（tail不为null）的话，调用一个CAS函数试图将node放入等待队列的尾部，注意，此时可能发生竞争，如果有另外一个线程在两个if之间抢先更新的队列的尾节点，CAS操作将会失败，这时会调用enq方法，继续试图将node放入队列：<br>enq方法会循环检测队列，如果队列为空，则调用CAS函数初始化队列（此时node==head==tail），否则调用CAS函数将node放入队列尾。注意，这两个CAS是由AQS提供的原子操作。如果CAS失败，enq会继续循环检测，直到成功将node入列。enq方法的这种方式有一个专用的名词：CAS自旋，这种方式在AQS中有多处应用。这里有一个隐含的知识点，即tail是一个volatile成员，确保某个线程更新队列后对其他线程的可见性。<br>注意：队列为空的时候，第一个线程进入队列的情况有点tricky：第一个发现队列为空并初始化队列（head节点）的线程不一定优先拿到资源。head节点被初始化后，当前线程需要下一次旋转才有机会进入队列，在这期间，完全有可能半路杀出程咬金，将当前线程与它初始化出的head节点无情分开。我们来总结一下，当队列只有一个节点时（head=tail），有两种情况：第一种是这个队列刚刚被初始化，head并没有持有任何线程对象。这个状态不会持续太久，初始化队列的线程有很大机会在下次自旋时把自己接到队尾。第二种情况是，所有等待线程都已经获得资源并继续执行下去了，队列仅有的节点是最后一个获取共享资源的线程，等到下一个线程到达等待队列并将它踢出队列之后，它才有机会被回收。<br>enq执行完毕，我们已经成功把当前线程放入等待队列，接下来的任务就是监视队列，等待获取资源。这个过程由acquireQueued方法实现：<br>acquireQueued方法是一个很重要的方法，在分析这个方法之前，我们先来说一下AQS中的那个等待队列。这个队列实际上是一个CLH队列，它保证了竞争资源的线程按到达顺序来获取资源，避免了饥饿的发生。CLH队列的工作过程，就是acquireQueued方法的工作过程。很明显，这又是一个自旋。首先，我们调用predecessor方法获取当前线程的前驱节点，如果这个前驱是head节点，就紧接着调用tryAcquire去获取共享资源，当然这是有可能失败的，因为head节点可能刚刚“上位”，还没有释放资源。如果很幸运，我们拿到了资源，就调用setHead将node设置为队列的头结点，setHead方法同时会将node的prev置为null，紧接着将原先head的next也置为null，显然这是为了让其后续被回收。注意：acquireQueued方法在自旋过程中是不可被中断的，当然它会检测到中断（在parkAndCheckInterrupt方法中检测中断标志），但并不会因此结束自旋，只能在获得资源退出方法后，反馈给上层的方法：我刚刚被中断了。还记得acquire方法中的selfInterrupt的调用吗，就是为了“补上”这里没有响应的中断。<br>好，我们继续往下。获取资源失败后（原因有二，head与我之间还有等待线程或者head节点的线程正在使用资源），调用shouldParkAfterFailedAcquire方法检测是否该去“休息”下，毕竟一直自旋很累嘛。如果可以休息就调用parkAndCheckInterrupt放心去休息。我们先来看一下shuldParkAfterFailedAcquire：<br>首先检测下node的前驱节点pred，如果pred状态已经被置为SIGNAL，直接返回true。否则，从node的前驱继续往前找，直到找到一个waitStatus小于等于0的节点，设置该点为node的前驱（注意：此时node与这个节点之间的节点从等待队列中被“摘下”，等待被回收了）并返回false。返回之后，上层的acquireQueued方法继续自旋，再次进入shouldParkAfterFailedAcquire方法之后，如果发现node前驱不是取消状态且waitStatus不等于SIGNAL，调用CAS函数进行注册。注意：这个操作可能失败，因此不能直接返回true，而是返回false由上层的自旋再次调用shouldParkAfterFailedAcquire直到确认注册成功。</p>
<p>AQS维护了一个FIFO队列，它是如何保证在运行期间不发生内存泄露的？<br>AQS在无竞争条件下，甚至都不会new出head和tail节点。<br>线程成功获取锁时设置head节点的方法为setHead，由于头节点的thread并不重要，此时会置node的thread和prev为null，<br>完了之后还会置原先head也就是线程对应node的前驱的next为null，从而实现队首元素的安全移出。<br>而在取消节点时，也会令node.thread = null，在node不为tail的情况下，会使node.next = node（之所以这样也是为了isOnSyncQueue实现更加简洁）</p>
<p>在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的对尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p>
<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p>AQS 的状态state是32位（int 类型）的，辦成两份，读锁用高16位，表示持有读锁的线程数（sharedCount），写锁低16位，表示写锁的重入次数 （exclusiveCount）。状态值为 0 表示锁空闲，sharedCount不为 0 表示分配了读锁，exclusiveCount 不为 0 表示分配了写锁，sharedCount和exclusiveCount 一般不会同时不为 0，只有当线程占用了写锁，该线程可以重入获取读锁，反之不成立。<br>ReentrantReadWriteLock中的类分成三个部分：<br>（1）ReentrantReadWriteLock本身实现了ReadWriteLock接口，这个接口只提供了两个方法readLock()和writeLock（）；<br>（2）同步器，包含一个继承了AQS的Sync内部类，以及其两个子类FairSync和NonfairSync；<br>（3）ReadLock和WriteLock两个内部类实现了Lock接口，它们具有锁的一些特性。<br>（1）ReentrantReadWriteLock采用读写锁的思想，能提高并发的吞吐量；<br>（2）读锁使用的是共享锁，多个读锁可以一起获取锁，互相不会影响，即读读不互斥；<br>（3）读写、写读和写写是会互斥的，前者占有着锁，后者需要进入AQS队列中排队；<br>（4）多个连续的读线程是一个接着一个被唤醒的，而不是一次性唤醒所有读线程；<br>（5）只有多个读锁都完全释放了才会唤醒下一个写线程；<br>（6）只有写锁完全释放了才会唤醒下一个等待者，这个等待者有可能是读线程，也可能是写线程；</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cqz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mega-cqz.github.io/2020/03/01/JUC/">https://mega-cqz.github.io/2020/03/01/JUC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mega-cqz.github.io">世界で一番おひめさま</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java-%E5%B9%B6%E5%8F%91/">Java,,并发    </a></div><div class="post_share"><div class="social-share" data-image="/img/Fate.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/02/feature/"><img class="prev_cover lazyload" data-src="/img/Fate.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>特征工程</span></div></a></div><div class="next-post pull_right"><a href="/2020/03/01/Java/"><img class="next_cover lazyload" data-src="/img/Fate.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Java</span></div></a></div></nav></div></main><footer id="footer" style="background-image: url(/img/Fate.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Cqz</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/ClickShowText.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":350,"height":500},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>