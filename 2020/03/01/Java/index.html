<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Java | 世界で一番おひめさま</title><meta name="description" content="Java"><meta name="keywords" content="Java,面试"><meta name="author" content="Cqz"><meta name="copyright" content="Cqz"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java"><meta name="twitter:description" content="Java"><meta name="twitter:image" content="https://mega-cqz.github.io/img/Fate.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java"><meta property="og:url" content="https://mega-cqz.github.io/2020/03/01/Java/"><meta property="og:site_name" content="世界で一番おひめさま"><meta property="og:description" content="Java"><meta property="og:image" content="https://mega-cqz.github.io/img/Fate.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://mega-cqz.github.io/2020/03/01/Java/"><link rel="prev" title="Java并发包" href="https://mega-cqz.github.io/2020/03/01/JUC/"><link rel="next" title="计算机网络" href="https://mega-cqz.github.io/2020/03/01/netword/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">世界で一番おひめさま</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/%E9%BB%84%E6%BC%AB%E8%80%81%E5%B8%88.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#基础"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">基础</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ArrayList与Vector的区别"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">ArrayList与Vector的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#List和-Map区别"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">List和 Map区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Object方法"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Object方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Equals"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Equals</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#hashcode"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">hashcode</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#进程与线程"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">进程与线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#进程间通信"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">进程间通信</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#线程间通信"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">线程间通信</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#内存变量交互"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">内存变量交互</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#线程调度"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">线程调度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#线程状态"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">线程状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#创建线程"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">创建线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#线程池"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">线程池</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程池队列"><span class="toc_mobile_items-number">14.1.</span> <span class="toc_mobile_items-text">线程池队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ThreadLoacl"><span class="toc_mobile_items-number">14.2.</span> <span class="toc_mobile_items-text">ThreadLoacl</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#内存泄漏"><span class="toc_mobile_items-number">14.3.</span> <span class="toc_mobile_items-text">内存泄漏</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Sleep-、suspend-和wait"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">Sleep()、suspend()和wait()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#start-和run"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text">start()和run()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Thread和实现runable接口"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text">Thread和实现runable接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Volatile"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text">Volatile:</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#volatile和synchronized"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text">volatile和synchronized</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ReenTrantLock"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text">ReenTrantLock</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#CAS"><span class="toc_mobile_items-number">21.</span> <span class="toc_mobile_items-text">CAS</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#AQS"><span class="toc_mobile_items-number">22.</span> <span class="toc_mobile_items-text">AQS</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Synchronized"><span class="toc_mobile_items-number">23.</span> <span class="toc_mobile_items-text">Synchronized</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Runnable接口和Callable接口"><span class="toc_mobile_items-number">24.</span> <span class="toc_mobile_items-text">Runnable接口和Callable接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java内存模型"><span class="toc_mobile_items-number">25.</span> <span class="toc_mobile_items-text">Java内存模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java执行顺序"><span class="toc_mobile_items-number">26.</span> <span class="toc_mobile_items-text">Java执行顺序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#抽象类与接口"><span class="toc_mobile_items-number">27.</span> <span class="toc_mobile_items-text">抽象类与接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#内存回收"><span class="toc_mobile_items-number">28.</span> <span class="toc_mobile_items-text">内存回收</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#回收区域"><span class="toc_mobile_items-number">28.1.</span> <span class="toc_mobile_items-text">回收区域</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#回收算法"><span class="toc_mobile_items-number">28.2.</span> <span class="toc_mobile_items-text">回收算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#finalize-："><span class="toc_mobile_items-number">28.3.</span> <span class="toc_mobile_items-text">finalize()：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#GC触发时间"><span class="toc_mobile_items-number">28.4.</span> <span class="toc_mobile_items-text">GC触发时间</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#java对象引用"><span class="toc_mobile_items-number">28.5.</span> <span class="toc_mobile_items-text">java对象引用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#关键字"><span class="toc_mobile_items-number">29.</span> <span class="toc_mobile_items-text">关键字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Final"><span class="toc_mobile_items-number">29.1.</span> <span class="toc_mobile_items-text">Final</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#CMS和G1"><span class="toc_mobile_items-number">30.</span> <span class="toc_mobile_items-text">CMS和G1</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java反射"><span class="toc_mobile_items-number">31.</span> <span class="toc_mobile_items-text">Java反射</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#动态代理与静态代理"><span class="toc_mobile_items-number">32.</span> <span class="toc_mobile_items-text">动态代理与静态代理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#String、StringBuffer与StringBuilder"><span class="toc_mobile_items-number">33.</span> <span class="toc_mobile_items-text">String、StringBuffer与StringBuilder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#For-Each"><span class="toc_mobile_items-number">34.</span> <span class="toc_mobile_items-text">For Each</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java权限"><span class="toc_mobile_items-number">35.</span> <span class="toc_mobile_items-text">Java权限</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Final-1"><span class="toc_mobile_items-number">36.</span> <span class="toc_mobile_items-text">Final</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Static"><span class="toc_mobile_items-number">37.</span> <span class="toc_mobile_items-text">Static</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Integer"><span class="toc_mobile_items-number">38.</span> <span class="toc_mobile_items-text">Integer</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#深拷贝与浅拷贝"><span class="toc_mobile_items-number">39.</span> <span class="toc_mobile_items-text">深拷贝与浅拷贝</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#泛型"><span class="toc_mobile_items-number">40.</span> <span class="toc_mobile_items-text">泛型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Netty"><span class="toc_mobile_items-number">41.</span> <span class="toc_mobile_items-text">Netty</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#I-O模型"><span class="toc_mobile_items-number">41.1.</span> <span class="toc_mobile_items-text">I&#x2F;O模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#BIO"><span class="toc_mobile_items-number">41.2.</span> <span class="toc_mobile_items-text">BIO</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#重写与重载"><span class="toc_mobile_items-number">42.</span> <span class="toc_mobile_items-text">重写与重载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#类加载"><span class="toc_mobile_items-number">43.</span> <span class="toc_mobile_items-text">类加载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#零拷贝"><span class="toc_mobile_items-number">44.</span> <span class="toc_mobile_items-text">零拷贝</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#值传递与引用传递"><span class="toc_mobile_items-number">45.</span> <span class="toc_mobile_items-text">值传递与引用传递</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#This用法"><span class="toc_mobile_items-number">46.</span> <span class="toc_mobile_items-text">This用法</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList与Vector的区别"><span class="toc-number">2.</span> <span class="toc-text">ArrayList与Vector的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List和-Map区别"><span class="toc-number">3.</span> <span class="toc-text">List和 Map区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object方法"><span class="toc-number">4.</span> <span class="toc-text">Object方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Equals"><span class="toc-number">5.</span> <span class="toc-text">Equals</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hashcode"><span class="toc-number">6.</span> <span class="toc-text">hashcode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程与线程"><span class="toc-number">7.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程间通信"><span class="toc-number">8.</span> <span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程间通信"><span class="toc-number">9.</span> <span class="toc-text">线程间通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存变量交互"><span class="toc-number">10.</span> <span class="toc-text">内存变量交互</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程调度"><span class="toc-number">11.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程状态"><span class="toc-number">12.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建线程"><span class="toc-number">13.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池"><span class="toc-number">14.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池队列"><span class="toc-number">14.1.</span> <span class="toc-text">线程池队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLoacl"><span class="toc-number">14.2.</span> <span class="toc-text">ThreadLoacl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄漏"><span class="toc-number">14.3.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sleep-、suspend-和wait"><span class="toc-number">15.</span> <span class="toc-text">Sleep()、suspend()和wait()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#start-和run"><span class="toc-number">16.</span> <span class="toc-text">start()和run()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread和实现runable接口"><span class="toc-number">17.</span> <span class="toc-text">Thread和实现runable接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Volatile"><span class="toc-number">18.</span> <span class="toc-text">Volatile:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#volatile和synchronized"><span class="toc-number">19.</span> <span class="toc-text">volatile和synchronized</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReenTrantLock"><span class="toc-number">20.</span> <span class="toc-text">ReenTrantLock</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS"><span class="toc-number">21.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS"><span class="toc-number">22.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Synchronized"><span class="toc-number">23.</span> <span class="toc-text">Synchronized</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Runnable接口和Callable接口"><span class="toc-number">24.</span> <span class="toc-text">Runnable接口和Callable接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java内存模型"><span class="toc-number">25.</span> <span class="toc-text">Java内存模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java执行顺序"><span class="toc-number">26.</span> <span class="toc-text">Java执行顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#抽象类与接口"><span class="toc-number">27.</span> <span class="toc-text">抽象类与接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存回收"><span class="toc-number">28.</span> <span class="toc-text">内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#回收区域"><span class="toc-number">28.1.</span> <span class="toc-text">回收区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回收算法"><span class="toc-number">28.2.</span> <span class="toc-text">回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalize-："><span class="toc-number">28.3.</span> <span class="toc-text">finalize()：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC触发时间"><span class="toc-number">28.4.</span> <span class="toc-text">GC触发时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java对象引用"><span class="toc-number">28.5.</span> <span class="toc-text">java对象引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关键字"><span class="toc-number">29.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Final"><span class="toc-number">29.1.</span> <span class="toc-text">Final</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CMS和G1"><span class="toc-number">30.</span> <span class="toc-text">CMS和G1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java反射"><span class="toc-number">31.</span> <span class="toc-text">Java反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态代理与静态代理"><span class="toc-number">32.</span> <span class="toc-text">动态代理与静态代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String、StringBuffer与StringBuilder"><span class="toc-number">33.</span> <span class="toc-text">String、StringBuffer与StringBuilder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#For-Each"><span class="toc-number">34.</span> <span class="toc-text">For Each</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java权限"><span class="toc-number">35.</span> <span class="toc-text">Java权限</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Final-1"><span class="toc-number">36.</span> <span class="toc-text">Final</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Static"><span class="toc-number">37.</span> <span class="toc-text">Static</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Integer"><span class="toc-number">38.</span> <span class="toc-text">Integer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深拷贝与浅拷贝"><span class="toc-number">39.</span> <span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型"><span class="toc-number">40.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty"><span class="toc-number">41.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O模型"><span class="toc-number">41.1.</span> <span class="toc-text">I&#x2F;O模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO"><span class="toc-number">41.2.</span> <span class="toc-text">BIO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写与重载"><span class="toc-number">42.</span> <span class="toc-text">重写与重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载"><span class="toc-number">43.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#零拷贝"><span class="toc-number">44.</span> <span class="toc-text">零拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#值传递与引用传递"><span class="toc-number">45.</span> <span class="toc-text">值传递与引用传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#This用法"><span class="toc-number">46.</span> <span class="toc-text">This用法</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/Fate.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Java</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-03-01<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-05</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>面向对象三个特性：封装 继承 多态</p>
<p>用最有效率的方法算出2乘以8等於几?<br>        2<< 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2<< 3</p>
<p>四类八种基本数据类型</p>
<ol>
<li>整型 byte（1字节） short （2个字节） int（4个字节） long （8个字节）</li>
<li>浮点型 float（4个字节） double（8个字节）</li>
<li>逻辑性 boolean（八分之一个字节）</li>
<li>字符型 char（2个字节，一个字符能存储下一个中文汉字）<br>一个字节8位</li>
</ol>
<h1 id="ArrayList与Vector的区别"><a href="#ArrayList与Vector的区别" class="headerlink" title="ArrayList与Vector的区别"></a>ArrayList与Vector的区别</h1><p>（1）同步性：<br>       Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。<br>（2）数据增长：<br>       ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。<br>总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。<br>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。</p>
<h1 id="List和-Map区别"><a href="#List和-Map区别" class="headerlink" title="List和 Map区别"></a>List和 Map区别</h1><p>一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</p>
<h1 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h1><p>Clone();hashcode;equals；tostring（方法返回此对象本身）；notify；wait；finalize</p>
<h1 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a>Equals</h1><p>==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。（比内存）<br>equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。（比看到的值）<br>String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串可以进行修改</p>
<p>hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？<br>       因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？<br>       因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：<br>1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。<br> 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。<br>        所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p>
<p>重写equals要点<br>equals方法实现了一个等价关系（equivalence relation）。它有以下这些属性:<br>• 自反性：对于任何非空引用x，x.equals(x)必须返回true。<br>• 对称性：对于任何非空引用x和y，如果且仅当y.equals(x)返回true时x.equals(y)必须返回true。<br>• 传递性：对于任何非空引用x、y、z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)必须返回true。<br>• 一致性：对于任何非空引用x和y，如果在equals比较中使用的信息没有修改，则x.equals(y)的多次调用必须始终返回true或始终返回false。<br>• 非空性: 对于任何非空引用x，x.equals(null)必须返回false。<br>当重写equals方法时，同时也要重写hashCode方法。</p>
<h1 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h1><p>不重写：Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。<br>若对一个类不重写，它的equals()方法是如何比较的？<br>比较是对象的地址。<br>Java对象的eqauls方法和hashCode方法是这样规定的：<br>➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>➁如果两个对象的hashCode相同，它们并不一定相同。 </p>
<p>为什么重写equals还要重写hashcode<br>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素 是否相等。重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。<br>发现test1()中，ArrayList只根据equals()来判断两个对象是否相等，而不管hashCode是否不相等。而test2()中，HashSet判断流程则不一样，①先判断两个对象的hashCode方法是否一样；②如果不一样，立即认为两个对象equals不相等，并不调用equals方法；③当hashCode相等时，再根据equals方法判断两个对象是否相等。<br>　　总结，所以当我们所写的类可能用于存放在Hash相关的集合类中时，在重写equals时，需要重写hashCode，不然会出现与预期不符的结果。</p>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>  进程：进程是一个程序在一个数据集合上的一次运行过程，是内存中正在执行的一个程序，每一个进程独立的占有内存空间。<br>线程：是进程中的一个实体，是被系统独立调度和执行的基本单位。<br>进程相当于线程在内执行的一个容器，本身是不活跃的，真正活跃的是线程，多个线程共享在一个进程中的地址空间，因此可以高效的共享数据；但是多个进程只能共享代码段，而不能共享数据。</p>
<p>全终止线程<br>public void Thread.interrupt()        //中断线程<br>public boolean Thread.isInterrupted() //判断线程是否中断<br>public static boolean Thread.interrupted() //判断是否被中断，并清除当前中断状态</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>（1）共享内存，独立的开辟一段内存空间，进程1往内存中写数据，进程2从内存中读数据，如果有其他进程，则另开辟内存空间即可。<br>（2）消息队列：可以传递消息<br>（3）管道：可以用来传递消息，但是是单向的<br>（4）互斥器：用来进程同步和互斥<br>（5）信号量：用来进程同步和互斥<br>（6）信号：用来进程同步和互斥<br>临界区：<br>临界区对应着一个CcriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。<br>PS:关键段对象会记录拥有该对象的线程句柄即其具有“线程所有权”概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。所以关键段可以用于线程间的互斥，但不可以用于同步（同步需要在一个线程进入，在另一个线程leave）<br>互斥量：<br>互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。<br>信号量：<br>信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作<br>事件：<br>事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。<br>争进程面临三个控制问题：<br>•    互斥：假设两个或更多进程需要访问一个不可共享的资源，如打印机。<br>•    临界资源：在执行过程中，每个进程都会给该i/o设备发命令，接受状态信息，发送数据和接收数据。这类资源称为临界资源。<br>•    临界区：使用临界资源的那部分程序称为程序的临界区。<br>进程间通过共享合作<br>进程间在互相并不确切知道对方的情况下进行交互。例如：多个进程可能访问一个共享变量，进程可能使用并修改共享变量而不涉及其他进程，但却知道其他进程也可能访问同一个数据。因此这些进程必须合作，以确保它们共享的数据得到正确管理。控制机制必须确保共享数据的完整性。<br>同步机制遵循规则：<br>    空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态 ，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效的利用临界资源。<br>    忙则等待：当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥和访问。<br>    有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。<br>让权等待：当今从不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。</p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>wait/notify 等待/唤醒<br>Volatile 内存共享<br>CountDownLatch 并发工具<br>CyclicBarrier 并发工具<br>线程锁：互斥锁，自旋锁：  应用在实时性要求较高的场合（缺点：CPU浪费较大），读写锁(共享-独占锁)：应用场景—大量的读操作  较少的写操作，条件变量：  如果说互斥锁是用于同步线程对共享数据的访问的化，那么条件变量这是用于在线程之间同步共享数据的值。条件变量提供了一种线程间的通信机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程<br>解决机制：加锁，不共享状态，不可变对象<br>锁升级技术：<br>锁优化技术：适应性自旋（Adaptive Spinning）、锁消除 （Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问 题，从而提高程序的执行效率<br>偏向锁：仅有一个线程进入临界区<br>几乎所有的锁都是可重入的，也即已经获得锁的线程可以多次锁住/解锁监视对象，按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操 作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个 线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。<br>轻量级锁：多个线程交替进入临界区<br>重量级锁：多个线程同时进入临界区<br>线程模型（虚拟机角度）：<br>要理解java的内存模型，可以类比计算机硬件访问内存的模型。由于计算机的cpu运算速度和内存io速度有几个数量级的差距，因此现代计算机都不得不加入一层尽可能接近处理器运算速度的高速缓存来做缓冲：将内存中运算需要使用的数据先复制到缓存中，当运算结束后再同步回内存。<br>因为jvm要实现跨硬件平台，因此jvm定义了自己的内存模型，但是因为jvm的内存模型最终还是要映射到硬件上，因此jvm内存模型几乎与硬件的模型一样：<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199745395.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199745395.png" class="lazyload"></a><br>每个java线程都有一份自己的工作内存，线程访问变量的时候，不能直接访问主内存中的变量，而是先把主内存的变量复制到自己的工作内存，然后操作自己工作内存里的变量，最后再同步给主内存。<br>现在就可以解释为什么5个线程执行a++最后结果不一定是5了，因为a++可以分解为3步操作：</p>
<ol>
<li>把主内存里的a复制到线程的工作内存</li>
<li>线程对工作内存里的a执行a=a+1</li>
<li>把线程工作内存里的a同步回主内存<br>而5个线程并发执行的时候完全有可能5个线程都先执行了第一步，这样5个线程的工作内存里a的初始值都是0，然后执行a=a+1后在工作内存里的运算结果都是1，最后同步回主内存的值肯定也是1。<br>而避免这种情况的方法就是：在多个线程并发访问a的时候，保证a在同一个时刻只被一个线程使用。<br>守护线程<br>是指在程序运行的时候在后台提供一种通用服务的线程。如gc。<br>非守护线程<br>也叫用户线程，由用户创建。<br>关系：<br>主线程和守护线程一起销毁；<br>主线程和非守护线程互不影响。<h1 id="内存变量交互"><a href="#内存变量交互" class="headerlink" title="内存变量交互"></a>内存变量交互</h1>这里的变量指的是可以放在堆中的变量，其他例如局部变量、方法参数这些并不算入在内。线程内存跟主内存变量之间的交互是非常重要的，Java虚拟机把这些交互规范为以下8种操作，每一种都是原子性的（非volatile修饰的Double和Long除外）操作。</li>
<li>Lock（锁）操作：操作对象为线程，作用对象为主内存的变量，当一个变量被锁住的时候，其他线程只有等当前线程解锁之后才能使用，其他线程不能对该变量进行解锁操作。</li>
<li>Unlock（解锁）操作：同上，线程操作，作用于主内存变量，令一个被锁住的变量解锁，使得其他线程可以对此变量进行操作，不能对未锁住的变量进行解锁操作。</li>
<li>Read（读）：线程从主内存读取变量值，load操作根据此读取的变量值为线程内存中的变量副本赋值。</li>
<li>Load（加载）：将Read读取到的变量值赋到线程内存的副本中，供线程使用。</li>
<li>Use（使用）：读取线程内存的作用值，用来执行我们定义的操作。</li>
<li>Assign（赋值）：在线程操作中变量的值进行了改变，使用此操作刷新线程内存的值。</li>
<li>Store（储存）：将当前线程内存的变量值同步到主内存中，与write操作一起作用。</li>
<li>Write（写）：将线程内存中store的值写入到主内存中，主内存中的变量值进行变更。</li>
</ol>
<p>对于普通的变量来说（非volatile修饰的变量），虚拟机要求read、load有相对顺序即可，例如从主内存读取i、j两个变量，可能的操作是read i=>read j=>load j=> load i，并不一定是连续的。此外虚拟机还为这8种操作定制了操作的规则：<br>•    （read，load）、（store，write）不允许出现单独的操作。也就是说这两种操作一定是以组的形式出现的，有read就有load，有store就有write，不能读取了变量值而不加载到线程内存中，也不能储存了变量值而不写到主内存中。<br>•    不允许线程放弃最近的assign操作。也就是说当线程使用assign操作对私有内存的变量副本进行了变更的时候，其必须使用write操作将其同步到主内存当中去。<br>•    不允许一个线程无原因地（没有进行assign操作）将私有内存的变量同步到主内存中。<br>•    变量必须从主内存产生，即不允许在私有内存中使用未初始化（未进行load或者assgin操作）的变量。也就是说，在use之前必须保证执行了load操作，在store之前必须保证执行了assign操作，例如有成员变量a和局部变量b，如果想进行a = b的操作，必须先初始化b。（一开始说了，变量指的是可以放在堆内存的变量）<br>•    一个变量一次只能同时允许一个线程对其进行lock操作。一个主内存的变量被一个线程使用lock操作之后，在这个线程执行unlock操作之前，其他线程不能对此变量进行操作。但是一个线程可以对一个变量进行多次锁，只要最后释放锁的次数和加锁的次数一致才能解锁。<br>•    当线程使用lock操作时，清除所有私有内存的变量副本。<br>•    使用unlock操作时，必须在此操作之前将变量同步到主内存当中。<br>•    不允许对没有进行lock操作的变量执行unlock操作，也不允许线程去unlock其他线程lock的变量。</p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><p>实现线程主要有三种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现。<br>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式分两种，分别是协同式线程调度和抢占式线程调度。<br>协同式线程调度，线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里。<br>抢占式调度，每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞。<br>Java线程调度就是抢占式调度。<br>希望系统能给某些线程多分配一些时间，给一些线程少分配一些时间，可以通过设置线程优先级来完成。Java语言一共10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两线程同时处于ready状态时，优先级越高的线程越容易被系统选择执行。但优先级并不是很靠谱，因为Java线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。</p>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>1、新建(New)：创建后尚未启动的线程。<br>2、运行(Runnable)：Runnable包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能等待CPU为它分配执行时间。线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。<br>3、无限期等待(Waiting)：该状态下线程不会被分配CPU执行时间，要等待被其他线程显式唤醒。如没有设置timeout的object.wait()方法和Thread.join()方法，以及LockSupport.park()方法。<br>4、限期等待(Timed Waiting)：不会被分配CPU执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后会由系统自动唤醒。如Thread.sleep()，设置了timeout的object.wait()和thread.join()，LockSupport.parkNanos()以及LockSupport.parkUntil()方法。<br>5、阻塞（Blocked）:线程被阻塞了。与等待状态的区别是：阻塞在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而等待则在等待一段时间，或唤醒动作的发生。在等待进入同步区域时，线程将进入这种状态。 </p>
<p>阻塞的情况分三种：<br>(1)、等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，，即无限期等待<br>(2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。<br>(3)、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。即限期等待。<br>这种情况下，五个状态分为 新建，就绪，运行，阻塞，终止，如下图所示。<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199885559.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199885559.png" class="lazyload"></a><br>6、结束(Terminated)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>1）继承Thread类创建线程<br>2）实现Runnable接口创建线程<br>3）使用Callable和Future创建线程<br>4）使用线程池例如用Executor框架</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>ThreadPoolExecutor mExecutor = new ThreadPoolExecutor(corePoolSize,// 核心线程数<br>                        maximumPoolSize, // 最大线程数<br>                        keepAliveTime, // 闲置线程存活时间<br>                        TimeUnit.MILLISECONDS,// 时间单位<br>                        new LinkedBlockingDeque<runnable>(),// 线程队列<br>                        Executors.defaultThreadFactory(),// 线程工厂<br>                        new AbortPolicy()// 队列已满,而且当前线程数已经超过最大线程数时的异常处理策略<br>线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</runnable></p>
<p>FixedThreadPool 定长线程池它是一种固定大小的线程池；创建一个定长线程池，支持定时及周期性任务执行，创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>CachedThreadPool 可缓存线程池它比较适合处理执行时间比较小的任务，先查看池中有没有以前建立的线程，如果有，就直接使用，没有就建立新线程<br>SingleThreadExecutor  单一线程池它只会创建一条工作线程处理任务，创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。<br>ScheduledThreadPool  可调度的线程池它用来处理延时任务或定时任务，创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。</p>
<p>线程拒绝策略：<br>ThreadPoolExecutor.AbortPolicy()，抛出java.util.concurrent.RejectedExecutionException异常<br>ThreadPoolExecutor.CallerRunsPolicy，用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。<br>RejectedExecutionHandler handler该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。<br>ThreadPoolExecutor.DiscardPolicy用于被拒绝任务的处理程序，默认情况下它将丢弃被拒绝的任务。</p>
<p>线程的局部变量隔离<br>ThreadLocal主要解决变量需要在线程内方法之间传递但在不同线程间隔离的问题。</p>
<p>最大线程池大小的设置首先跟当前机器cpu核心数密切相关，一般情况来说要想最大化利用cpu，设置为cpu核心数就可以了，比如4核cpu服务器可以设置为4。但实际情况又大有不同，因为往往我们执行的任务都会涉及到IO，比如任务中执行了一个从数据库查询数据的操作，那么这段时间cpu实际上是没有最大化利用的，这样我们就可以适当扩大maximumPoolSize的大小。在有些情况下任务会是cpu密集型的，如果这样设置更多的线程不仅不会提高效率，反而因为线程的创建销毁以及切换开销而大大降低了效率，所以说最大线程池的大小需要根据业务情况具体测试后才能设置一个合适的大小。</p>
<p>最小线程池大小相比较最大线程池大小设置起来相对容易一些，因为最小线程一般来说是可以根据业务情况来预估进行设置，比如大多数情况下会有2个任务在运行，很小概率会有超过2个任务运行，那么直接设置最小线程池大小为2就可以。但有一点需要知道的是每间隔多长时间会有超过2个任务，如果每2分钟会有一次超过2个任务的情况，那么我们可以将线程过期时间设置的稍微久一点，比如4分钟，这样就算频繁的超过2个任务，也可以利用缓存的线程池。<br>总的来说设置最大和最小线程池都是一个没有固定公式的问题，都需要考虑实际业务情况和机器配置，根据实际业务情况多做测试才能做到最优化设置。在一切没有决定之前，可以使用软件架构的KISS原则，设置最大以及最小线程数都为cpu核心数即可，后续在做优化。</p>
<p>当一个任务通过execute(Runnable)方法欲添加到线程池时：<br>l  如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。<br>2  如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。<br>3  如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的进程处理被添加的任务。<br>4  如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。<br>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200074608.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200074608.png" class="lazyload"></a></p>
<h2 id="线程池队列"><a href="#线程池队列" class="headerlink" title="线程池队列"></a>线程池队列</h2><p>用来保存等待被执行的任务的阻塞队列. 在JDK中提供了如下阻塞队列：<br>(1) ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；<br>(2) LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；<br>(3) SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；<br>(4) priorityBlockingQuene：具有优先级的无界阻塞队列；</p>
<h2 id="ThreadLoacl"><a href="#ThreadLoacl" class="headerlink" title="ThreadLoacl"></a>ThreadLoacl</h2><p>每个线程自身都维护着一个ThreadLocalMap，用来存储线程本地的数据，可以简单理解成ThreadLocalMap的key是ThreadLocal变量，value是线程本地的数据。就这样很简单的实现了线程本地数据存储和交互访问。</p>
<p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：<br>•    因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。<br>•    既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题。<br>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。<br>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。<br>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。<br>内存泄漏问题<br>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。<br>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。<br>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。<br>使用场景<br>如上文所述，ThreadLocal 适用于如下两种场景<br>•    每个线程需要有自己单独的实例<br>•    实例需要在多个方法中共享，但不希望被多线程共享<br>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。<br>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。<br>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>1、使用静态的集合类<br>    静态的集合类的生命周期和应用程序的生命周期一样长，所以在程序结束前容器中的对象不能被释放，会造成内存泄露。解决办法是最好不使用静态的集合类，如果使用的话，在不需要容器时要将其赋值为null。<br>2 、单例模式可能会造成内存泄露<br>    单例模式只允许应用程序存在一个实例对象，并且这个实例对象的生命周期和应用程序的生命周期一样长，如果单例对象中拥有另一个对象的引用的话，这个被引用的对象就不能被及时回收。解决办法是单例对象中持有的其他对象使用弱引用，弱引用对象在GC线程工作时，其占用的内存会被回收掉，<br>3 、变量不合理的作用域<br>如果变量的定义范围大于使用范围，并且在使用完后没有赋值为null的话，会出现内存泄露。定义变量的时候，能定义为局部变量就不要定义为成员变量，或者定义为成员变量的话，在使用完变量后，把变量赋值为null。<br>4、数据库、网络、输入输出流，这些资源没有显示的关闭<br>    垃圾回收只负责内存回收，如果对象正在使用资源的话，Java虚拟机不能判断这些对象是不是正在进行操作，比如输入输出，也就不能回收这些对象占用的内存，所以在资源使用完后要调用close()方法关闭。<br>5、使用非静态内部类<br>    非静态内部类对象的构建依赖于其外部类，内部类对象会持有外部类对象的this引用，即时外部类对象不再被使用了，其占用的内存可能不会被GC回收，因为内部类的生命周期可能比外部类的生命周期要长，从而造成外部类对象不能被及时回收。解决办法是尽量使用静态内部类，静态内部类只是形式上在外部类的里面，静态内部类不会持有外部类的引用，可以把静态内部类理解成是一个独立的类，和外部类没什么关系。<br>    引申：为什么非静态内部类对象会持有外部类对象的this引用？<br>   非静态内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的class文件，通过如下三个步骤，内部类对象通过this访问外部类对象的成员。<br>1） 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象(this)的引用；<br>2） 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为内部类中添加的成员变量赋值；<br>3）在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。</p>
<h1 id="Sleep-、suspend-和wait"><a href="#Sleep-、suspend-和wait" class="headerlink" title="Sleep()、suspend()和wait()"></a>Sleep()、suspend()和wait()</h1><p>Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。<br>注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。</p>
<p>object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()/notify()与sleep()/interrupt()类似，只是前者需要获取对象锁。</p>
<p>1、同步锁的对待不同：<br>sleep（）后，程序并不会不释放同步锁。<br>wait（）后，程序会释放同步锁。<br>2、用法的不同：<br>sleep（）可以用时间指定来使他自动醒过来。如果时间不到你只能调用interreput()来强行打断。<br>wait（）可以用notify()直接唤起。</p>
<p>一、sleep()方法是属于线程类Thread中的一个方法，而wait()方法属于Object。<br>二、sleep方法是让线程休眠指定的时间，单位毫秒，让出cpu给其他线程，但它的监控状态依然保持着，指定时间到了自动恢复sleep前的状态。在sleep过程中线程不会释放对象锁。谁调用sleep谁睡眠，在A线程中调用B线程的sleep方法，是A线程去睡眠。<br>只能从同步块中调用wait()方法，线程会放弃对象锁，让其他线程可以获得对象锁。<br>如果直接调用 wait 会抛出 java.lang.IllegalMonitorStateException 异常，原因是还没有得到对象锁，所以无法释放锁。<br>线程wait后要等待其他线程调用 notify 或 notifyAll 对  锁的对象唤醒！<br>三、sleep方法需要抛异常,wait方法不需要<br>注意sleep方法是单线程的,没有释放锁,这个锁指的是线程锁,不是对象锁,而wait方法释放锁,这个锁是对象锁,所以sleep时间到和wait等到notify之后享受的待遇一样,都是回到就绪状态,等待系统分配cpu</p>
<p>Thread.Sleep(1000) 意思是在未来的1000毫秒内本线程不参与CPU竞争，1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。另外值得一提的是Thread.Sleep(0)的作用，就是触发操作系统立刻重新进行一次CPU竞争，竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。<br>wait(1000)表示将锁释放1000毫秒，到时间后如果锁没有被其他线程占用，则再次得到锁，然后wait方法结束，执行后面的代码，如果锁被其他线程占用，则等待其他线程释放锁。注意，设置了超时时间的wait方法一旦过了超时时间，并不需要其他线程执行notify也能自动解除阻塞，但是如果没设置超时时间的wait方法必须等待其他线程执行notify。</p>
<h1 id="start-和run"><a href="#start-和run" class="headerlink" title="start()和run()"></a>start()和run()</h1><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h1 id="Thread和实现runable接口"><a href="#Thread和实现runable接口" class="headerlink" title="Thread和实现runable接口"></a>Thread和实现runable接口</h1><p>thread也实现了runable接口<br>Thread类也实现了Runnable接口，应尽量使用实现Runnable的方式，因为实现Runnable接口的方式比继承Thread类方法多以下优势：<br>① 适合多个相同程序代码的线程去处理同一资源；<br>② 避免了Java单继承带来的局限性；<br>③ 增强了程序的健壮性，代码能被多个线程共享，代码与数据是独立的。</p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile:"></a>Volatile:</h1><p>前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。<br>一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。<br>一个线程的所有操作都会在线程终止之前，线程终止规则。<br>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。<br>禁止指令重排序优化<br>（1）volatile关键字可以保证可见性；<br>（2）volatile关键字可以保证有序性；<br>（3）volatile关键字不可以保证原子性；<br>（4）volatile关键字的底层主要是通过内存屏障来实现的；<br>（5）volatile关键字的使用场景必须是场景本身就是原子的；<br>volatile可见性的实现就是借助了CPU的lock指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则：</p>
<ol>
<li>写volatile时处理器会将缓存写回到主内存。</li>
<li>一个处理器的缓存写回到内存会导致其他处理器的缓存失效。</li>
</ol>
<h1 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h1><ol>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化<h1 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h1>不可重入锁<br>所谓不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。<br>所谓可重入，意味着线程可以进入它已经拥有的锁的同步代码块儿。<br>可重入性：<br>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。<br>锁的实现：<br>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。<br>性能的区别：<br>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。<br>功能区别：<br>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。<br>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized<br>ReenTrantLock独有的能力：</li>
<li>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li>
<li>ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li>
<li>ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。<br>ReenTrantLock实现的原理：<br>简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。<br>什么情况下使用ReenTrantLock：<br>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</li>
</ol>
<p>ReentrantLock的底层实现机制是AQS(Abstract Queued Synchronizer 抽象队列同步器)。AQS没有锁之类的概念，它有个state变量，是个int类型，为了好理解，可以把state当成锁，AQS围绕state提供两种基本操作“获取”和“释放”，有条双向队列存放阻塞的等待线程。AQS的功能可以分为独占和共享，ReentrantLock实现了独占功能（每次只能有一个线程能持有锁）。<br>ReentrantLock的基本实现可以概括为：先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入CLH队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：<br>•    非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；<br>•    公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。<br>可见性：ReentrantLock的同步其实是委托给AbstractQueuedSynchronizer的。加锁和解锁是通过改变AbstractQueuedSynchronizer的state属性，这个属性是volatile的，volatile也能保证可见性。和你说的“比如A类的成员变量b，线程1在synchronized块中修改A.b，在synchronized块离开前肯定会把修改的值从工作内存flush到主内存中，然后当线程2在synchronized块中读取A.b，工作内存会被设置无效，所以从主内存中读取它的实际值，这样完成了A.b的可见性。”是一样的。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作。<br>compareAndSwapInt就是借助C语言和汇编代码来实现的。<br>concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ol>
<li>首先，声明共享变量为volatile；</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。<br>ABA问题用版本号来解决，自旋时n间过长问题可以通过上次自旋时间来进</li>
</ol>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。鉴于此，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了保证同步，必须原子地操作这些变量。</p>
<p>模板方法：模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现。<br>CHL队列：CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。AQS使用的是CHL的变种。<br>CAS操作：compare and swap技术 ，底层调用 Unsafe类<br>LockSupport类对线程的操作支持：LockSupport.park() 阻塞线程，LockSupport.unpark() 唤醒线程，底层调用 Unsafe类 。<br>Unsafe类：Unsafe是Java中一个底层类，包含了很多基础的操作，比如数组操作、对象操作、内存操作、CAS操作、线程(park)操作、栅栏（Fence）操作，JUC包、一些三方框架都使用Unsafe类来保证并发安全。其中AQS中使用到  Unsafe线程操作.许可线程通过（park），或者让线程等待许可(unpark);Unsafe的CAS操作 在Unsafe中包含compareAndSwapObject、compareAndSwapInt、compareAndSwapLong三个方法<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199528640.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199528640.png" class="lazyload"></a></p>
<p>如图示，AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：<br>getState();setState();compareAndSetState();<br>AQS 定义了两种资源共享方式：<br>1.Exclusive：独占，只有一个线程能执行，如ReentrantLock<br>2.Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier<br>同步器的设计是基于模板方法模式<br>AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。<br>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。<br>注意：AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功<br>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物<br>AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。<br>AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。</p>
<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>可见性：确保变量在内存的可见性 - 即当读写两个线程同时访问同一个变量时，synchronized用于确保写线程更新变量后，读线程再访问该 变量时可以读取到该变量最新的值。<br>synchronized给出的答案是在软件层面依赖JVM，而Lock给出的方案是在硬件层面依赖特殊的CPU指令，首先，对synchronized的代码块先说明一下，它是由一对儿monitorenter/monitorexit指令实现的，Monitor对象是同步的基本实现单元。<br>按偏向锁->轻量级锁->重量级锁 的顺序升级<br>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199570766.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199570766.png" class="lazyload"></a><br>Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<p>（1）偏向锁，是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价。<br>（2）轻量级锁，是指当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，这个线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能。<br>（3）重量级锁，是指当锁是轻量级锁时，当自旋的线程自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低。</p>
<p>总结<br>（1）synchronized在编译时会在同步块前后生成monitorenter和monitorexit字节码指令；<br>（2）monitorenter和monitorexit字节码指令需要一个引用类型的参数，基本类型不可以哦；<br>（3）monitorenter和monitorexit字节码指令更底层是使用Java内存模型的lock和unlock指令；<br>（4）synchronized是可重入锁；<br>（5）synchronized是非公平锁；<br>（6）synchronized可以同时保证原子性、可见性、有序性；<br>（7）synchronized有三种状态：偏向锁、轻量级锁、重量级锁；</p>
<h1 id="Runnable接口和Callable接口"><a href="#Runnable接口和Callable接口" class="headerlink" title="Runnable接口和Callable接口"></a>Runnable接口和Callable接口</h1><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。<br>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199184713.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199184713.png" class="lazyload"></a></p>
<h1 id="Java执行顺序"><a href="#Java执行顺序" class="headerlink" title="Java执行顺序"></a>Java执行顺序</h1><p>①父类静态变量和静态代码块(按照声明顺序)；<br>②子类静态变量和静态代码块(按照声明顺序)；<br>③父类成员变量和代码块(按照声明顺序)；<br>④父类构造器；<br>⑤子类成员变量和代码块(按照声明顺序)；<br>⑥子类构造器。</p>
<h1 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h1><ol>
<li>一个子类只能继承一个抽象类,但能实现多个接口 </li>
<li>抽象类可以有构造方法,接口没有构造方法 </li>
<li>抽象类可以有普通成员变量,接口没有普通成员变量 </li>
<li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认) </li>
<li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法 </li>
<li>抽象类可以有静态方法,接口不能有静态方法 </li>
<li>抽象类中的方法可以是public、protected;接口方法只有public<br>不允许多重extends的理由是为了避免多重继承，如果允许多重继承，那么就可以获得多个被继承者的变量。假如你定义一个类继承多个class, 当你通过创建方法获得一个实例时，这个实例会得到所有被它extends也就是所有父类的变量/方法，如果多个父类有同一个变量，那将造成混乱。接口没有变量，则没有以上的矛盾。<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><h2 id="回收区域"><a href="#回收区域" class="headerlink" title="回收区域"></a>回收区域</h2>JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样这部分内存的分配和回收是动态的。<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2>标记-清除算法：<br>标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</li>
</ol>
<p>复制算法<br>  复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p>
<p>标记-整理算法<br>  标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。具</p>
<p>分代收集算法<br>  分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p>
<h2 id="finalize-："><a href="#finalize-：" class="headerlink" title="finalize()："></a>finalize()：</h2><p>  Java中假定finalize的工作原理为：一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！<br>finalize()的作用：finalize用于在GC发生前事先调用去回收JNI调用中申请的特殊内存，下次GC发生时候保证GC后所有该对象的内存都释放了。</p>
<h2 id="GC触发时间"><a href="#GC触发时间" class="headerlink" title="GC触发时间"></a>GC触发时间</h2><p> 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。<br> Scavenge GC<br>  一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。<br>Full GC<br>  对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：<br>a) 年老代（Tenured）被写满；<br>b) 持久代（Perm）被写满；<br>c) System.gc()被显示调用；<br>d) 上一次GC之后Heap的各域分配策略动态变化；</p>
<p>Minor GC ，Full GC 触发条件<br>Minor GC触发条件：当Eden区满时，触发Minor GC。<br>Full GC触发条件：<br>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行<br>（2）老年代空间不足<br>（3）方法区空间不足<br>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199430074.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199430074.png" class="lazyload"></a></p>
<h2 id="java对象引用"><a href="#java对象引用" class="headerlink" title="java对象引用"></a>java对象引用</h2><p>java对象的引用包括<br>  强引用，软引用，弱引用，虚引用<br>Java中提供这四种引用类型主要有两个目的：<br>第一是可以让程序员通过代码的方式决定某些对象的生命周期；<br>第二是有利于JVM进行垃圾回收。<br> 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。 是指创建一个对象并把这个对象赋给一个引用变量。<br>如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；<br>如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<br>软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。<br>SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。<br>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱引用也是用来描述非必需对象的<br>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199632231.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583199632231.png" class="lazyload"></a></p>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>修饰类当用final去修饰一个类的时候，表示这个类不能被继承。注意：a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。b. final类中的成员方法都会被隐式的指定为final方法。说明：在自己设计一个类的时候，要想好这个类将来是否会被继承，如果可以被继承，则该类不能使用fianl修饰，在这里呢，一般来说工具类我们往往都会设计成为一个fianl类。在JDK中，被设计为final类的有String、System等<br>2. 修饰方法<br>被final修饰的方法不能被重写。<br>注意：<br>a. 一个类的private方法会隐式的被指定为final方法。<br>b. 如果父类中有final修饰的方法，那么子类不能去重写。<br>3. 修饰成员变量<br>注意：<br>必须要赋初始值，而且是只能初始化一次。<br>(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p>
<h1 id="CMS和G1"><a href="#CMS和G1" class="headerlink" title="CMS和G1"></a>CMS和G1</h1><p>CMS：以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现<br>过程：<br>1、初始标记：独占PUC，仅标记GCroots能直接关联的对象<br>2、并发标记：可以和用户线程并行执行，标记所有可达对象<br>3、重新标记：独占CPU(STW)，对并发标记阶段用户线程运行产生的垃圾对象进行标记修正<br>4、并发清理：可以和用户线程并行执行，清理垃圾<br>优点:<br>并发，低停顿<br>缺点：<br>1、对CPU非常敏感：在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢<br>2、无法处理浮动垃圾：在最后一步并发清理过程中，用户县城执行也会产生垃圾，但是这部分垃圾是在标记之后，所以只有等到下一次gc的时候清理掉，这部分垃圾叫浮动垃圾<br>3、CMS使用“标记-清理”法会产生大量的空间碎片，当碎片过多，将会给大对象空间的分配带来很大的麻烦，往往会出现老年代还有很大的空间但无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC，为了解决这个问题CMS提供了一个开关参数，用于在CMS顶不住，要进行FullGC时开启内存碎片的合并整理过程，但是内存整理的过程是无法并发的，空间碎片没有了但是停顿时间变长了<br>CMS 出现FullGC的原因：<br>1、年轻带晋升到老年带没有足够的连续空间，很有可能是内存碎片导致的<br>2、在并发过程中JVM觉得在并发过程结束之前堆就会满，需要提前触发FullGC</p>
<p>G1：是一款面向服务端应用的垃圾收集器<br>特点：<br>1、并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。<br>2、分代收集：分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说G1可以自己管理新生代和老年代了。<br>3、空间整合：由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。<br>4、可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<br>5 维护Region垃圾回收价值列表，优先回收价值大的</p>
<p>与其它收集器相比，G1变化较大的是它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留了新生代和来年代的概念，但新生代和老年代不再是物理隔离的了它们都是一部分Region（不需要连续）的集合。同时，为了避免全堆扫描，G1使用了Remembered Set来管理相关的对象引用信息。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏了。</p>
<p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：<br>1、初始标记（Initial Making）<br>2、并发标记（Concurrent Marking）<br>3、最终标记（Final Marking）<br>4、筛选回收（Live Data Counting and Evacuation）<br>看上去跟CMS收集器的运作过程有几分相似，不过确实也这样。初始阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以用的Region中创建新对象，这个阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这一阶段耗时较长但能与用户线程并发运行。而最终标记阶段需要吧Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但可并行执行。最后筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这一过程同样是需要停顿线程的，但Sun公司透露这个阶段其实也可以做到并发，但考虑到停顿线程将大幅度提高收集效率，所以选择停顿。下图为G1收集器运行示意图：<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200405771.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200405771.png" class="lazyload"></a><br>GC Roots的对象</p>
<ol>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。(可以理解为:引用栈帧中的本地变量表的所有对象)</li>
<li>方法区中静态属性引用的对象(可以理解为:引用方法区该静态属性的所有对象)</li>
<li>方法区中常量引用的对象(可以理解为:引用方法区中常量的所有对象)</li>
<li>本地方法栈中(Native方法)引用的对象(可以理解为:引用Native方法的所有对象)<br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。<br>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。<br>1).第一次标记并进行一次筛选。<br>筛选的条件是此对象是否有必要执行finalize()方法。<br>当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。<br>2).第二次标记<br>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<br>Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己—-只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</li>
</ol>
<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><p>什么是反射机制<br>        简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，<br>    那么就可以通过反射机制来获得类的所有信息。<br>二、哪里用到反射机制<br> 添加一句：所有类的对象其实都是Class的实例。<br>        有些时候，我们用过一些知识，但是并不知道它的专业术语是什么，在刚刚学jdbc时用过一行代码，<br>    Class.forName(“com.mysql.jdbc.Driver.class”).newInstance();但是那时候只知道那行代码是生成 </p>
<p>Java反射机制主要提供了以下功能：<br>在运行时判断任意一个对象所属的类；<br>在运行时构造任意一个类的对象；<br>在运行时判断任意一个类所具有的成员变量和方法；<br>在运行时调用任意一个对象的方法；生成动态代理。</p>
<p>Java反射原理<br>1.将Java文件保存到本地硬盘<br>2.编译Java文件，生成.class文件<br>3.使用Java虚拟机（JVM）将字节码文件加载到内存<br>4.字节码文件在内存中使用Class类表示<br>5.使用反射的时候，首先获取到Class类，就可以得到class文件里的所有内容，包含属性、构造方法、普通方法<br>6.属性通过Filed类表示<br>7.构造方法通过Constructor表示<br>8.普通方法通过Method表示</p>
<p>带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。<br>反射的缺点 Drawbacks of Reflection<br>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心：<br>性能第一 Performance Overhead<br>反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用反射。<br>安全限制 Security Restrictions<br>使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了。。<br>内部暴露 Exposure of Internals<br>由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。<br>Java的反射机制在做基础框架的时候非常有用，当你做一个软件可以安装插件的功能，你连插件的类型名称都不知道，你怎么实例化这个对象呢？因为程序是支持插件的（第三方的），在开发的时候并不知道 。所以无法在代码中 New出来 ，但反射可以，通过反射，动态加载程序集，然后读出类，检查标记之后再实例化对象，就可以获得正确的类实例。</p>
<p>3）在编码阶段不知道那个类名,要在运行期从配置文件读取类名, 这时候就没有办法硬编码new ClassName(),而必须用到反射才能创建这个对象.反射的目的就是为了扩展未知的应用。比如你写了一个程序，这个程序定义了一些接口，只要实现了这些接口的dll都可以作为插件来插入到这个程序中。那么怎么实现呢？就可以通过反射来实现。就是把dll加载进内存，然后通过反射的方式来调用dll中的方法。很多工厂模式就是使用的反射。</p>
<h1 id="动态代理与静态代理"><a href="#动态代理与静态代理" class="headerlink" title="动态代理与静态代理"></a>动态代理与静态代理</h1><p>静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。<br>动态代理类：在程序运行时，运用反射机制动态创建而成。<br>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。<br>静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。<br>动态代理是实现JDK里的InvocationHandler接口的invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。</p>
<h1 id="String、StringBuffer与StringBuilder"><a href="#String、StringBuffer与StringBuilder" class="headerlink" title="String、StringBuffer与StringBuilder"></a>String、StringBuffer与StringBuilder</h1><p>String内容不可变，StringBuffer和StringBuilder内容可变；<br>StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用synchronized加锁了）；<br>如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。<br>•  String是值不可变的常量，是线程安全的(can be shared)。<br>•  String类使用了final修饰符，String类是不可继承的<br>Java 中 String底层是采用char数组实现的，存放字符的数组被声明为 final 的 ，因此是不可变的。<br>StringBuffer继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串。</p>
<h1 id="For-Each"><a href="#For-Each" class="headerlink" title="For Each"></a>For Each</h1><p>For each中插入删除会抛出ConcurrentModificationException异常。<br>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出java.util.ConcurrentModificationException异常。<br>所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。<br>针对数据查询而言<br> 对于使用数组作为存储结构的数据结构而言, 由于数组可以随机存储, 循环而言就是直接调用get(i), 这两者区别不大.<br> 对于使用链表数据结构存储的数据而言,for循环要获取第i个元素必须从头开始遍历,所以for循环效率明显比foreach低.<br>针对数据修改而言, foreach不能对数组或集合进行修改(添加删除操作), 如果想要修改就要用for循环.<br>总结：<br>foreach对于循环次数未知时, 或循环次数较麻烦时, 效率较高;<br>对于循环数据修改只能使用for, 其实相比较而言, 可能for循环更加灵活.<br>Iterator遍历时不可以删除集合中的元素问题<br> 　　在使用Iterator的时候禁止对所遍历的容器进行改变其大小结构的操作。例如: 在使用Iterator进行迭代时，如果对集合进行了add、remove操作就会出现ConcurrentModificationException异常。<br>因为在你迭代之前，迭代器已经被通过list.itertor()创建出来了，如果在迭代的过程中，又对list进行了改变其容器大小的操作，那么Java就会给出异常。因为此时Iterator对象已经无法主动同步list做出的改变，Java会认为你做出这样的操作是线程不安全的，就会给出善意的提醒（抛出ConcurrentModificationException异常）通过查看源码发现原来检查并抛出异常的是checkForComodification()方法。在ArrayList中modCount是当前集合的版本号，每次修改(增、删)集合都会加1；expectedModCount是当前迭代器的版本号，在迭代器实例化时初始化为modCount。我们看到在checkForComodification()方法中就是在验证modCount的值和expectedModCount的值是否相等，所以当你在调用了ArrayList.add()或者ArrayList.remove()时，只更新了modCount的状态，而迭代器中的expectedModCount未同步，因此才会导致再次调用Iterator.next()方法时抛出异常。但是为什么使用Iterator.remove()就没有问题呢？通过源码的第32行发现，在Iterator的remove()中同步了expectedModCount的值，所以当你下次再调用next()的时候，检查不会抛出异常。<br>　　使用该机制的主要目的是为了实现ArrayList中的快速失败机制（fail-fast），在Java集合中较大一部分集合是存在快速失败机制的。<br>　　快速失败机制产生的条件:当多个线程对Collection进行操作时，若其中某一个线程通过Iterator遍历集合时，该集合的内容被其他线程所改变，则会抛出ConcurrentModificationException异常。<br>　　所以要保证在使用Iterator遍历集合的时候不出错误，就应该保证在遍历集合的过程中不会对集合产生结构上的修改。<br> 使用Foreach时对集合的结构进行修改会出现异常:<br>　　上面我们说了实现了Iterable接口的类就可以通过Foreach遍历，那是因为foreach要依赖于Iterable接口返回的Iterator对象，所以从本质上来讲，Foreach其实就是在使用迭代器，在使用foreach遍历时对集合的结构进行修改，和在使用Iterator遍历时对集合结构进行修改本质上是一样的。所以同样的也会抛出异常，执行快速失败机制。<br>foreach是JDK1.5新增加的一个循环结构，foreach的出现是为了简化我们遍历集合的行为。<br>迭代器对列表中元素的遍历是通过next函数来实现的，新创建的迭代器默认指向列表中的第一个元素，每执行一次next，Iterator迭代器的游标都会指向下一个元素。迭代器的remove操作删除的是最近一次由next操作获取的元素，而不是当前游标所指向的元素。<br>在使用Iterator的时候，迭代器会新建一个线程，把原来的线程中的对象重新拷贝一份，在进行删除，修改等操作时，原来的线程只负责迭代，而Iterator负责迭代和删除操作，Iterator每次迭代都会检查迭代器里的对象和原线程中的对象个数是否一致，不一致则抛出：ConcurrentModificationException。Iterator中的remove<br>default void remove()<br>从基础集合中移除这个迭代器返回的最后一个元素（可选操作）。两个线程中都删除，保证线程的同步。</p>
<p>Jvm里用invokeDynamic，在延迟Lambda表达式到字节码的转换，最终这一操作被推迟到运行时，将实现Lambda表达式的这部分代码的字节码生成推迟到运行时<br>java程序在运行的过程中，有时候我们会需要了解程序的内部运行情况，这个时候就可以使用jstat命令，jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。</p>
<h1 id="Java权限"><a href="#Java权限" class="headerlink" title="Java权限"></a>Java权限</h1><p>public：可以被所有其他类所访问<br>private：只能被自己访问和修改<br>protected：自身、子类及同一个包中类可以访问<br>default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200435594.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200435594.png" class="lazyload"></a></p>
<h1 id="Final-1"><a href="#Final-1" class="headerlink" title="Final"></a>Final</h1><p>1、用来修饰一个引用<br> 如果引用为基本数据类型，则该引用为常量，该值无法修改；<br> 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。<br> 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。<br>2.用来修饰一个方法<br>    当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。<br>3.用来修饰类<br> 当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。<br>如String类<br> 对数据：常量，不可变；基本数据类型的变量，数值一旦在初始化之后便不能更改；如果是引用类型的变量，初始化之后便不能再指向另一个对象。<br>    对方法：不可被子类重写（类的private方法会隐式地被指定为final方法）<br>    对类：不可继承（final类中的所有成员方法都会被隐式地指定为final方法。）</p>
<h1 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h1><p>静态变量，被所有的对象所共享，在内存中只有一个副本。在类初次加载时初始化。非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。<br>静态方法：只依赖于类。修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。因此对于静态方法来说，没有this，在静态方法中不能访问类的非静态成员变量和非静态成员方法。<br>static代码块：形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。因为它的特性:只会在类加载的时候执行一次。<br>static的代码会最先被加载</p>
<h1 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h1><p>int与integer的区别从大的方面来说就是基本数据类型与其包装类的区别：<br>int 是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象<br>.Java 中的数据类型分为基本数据类型和复杂数据类型<br>int 是前者而integer 是后者（也就是一个类）；因此在类进行初始化时int类的变量初始为0.而Integer的变量则初始化为null.<br>举个例子：当需要往ArrayList，HashMap中放东西时，像int，double这种内建类型是放不进去的，因为容器都是装 object的，这是就需要这些内建类型的外覆类了<br>如果我们定义一个int类型的数，只是用来进行一些加减乘除的运算or作为参数进行传递，那么就可以直接声明为int基本数据类型，但如果要像<br>对象一样来进行处理，那么就要用Integer来声明一个对象，因为java是面向对象的语言，因此当声明为对象时能够提供很多对象间转换的方式，与一些常用<br>的方法。自认为java作为一们面向对象的语言，我们在声明一个变量时最好声明为对象格式，这样更有利于你对面向对象的理解<br>Integer：Integer的缓存机制，缓存了从 -128 到 127 内的所有 Integer 值，若是该范围内 Integer 值，不会初始化，直接从缓存拿.<br>这种缓存行为不仅适用于整数对象。我们针对所有的整数类型的类都有类似的缓存机制。<br>有ByteCache用于缓存字节对象<br>有ShortCache用于缓存短对象<br>有LongCache用于缓存长对象<br>有CharacterCache用于缓存字对象<br>Byte，Short，Long有固定范围：-128到127<br>对于Character，范围是0到127。除了Integer以外，这个范围都不能改变。<br>我们都知道在Java语言中，new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。<br>对于经常用到的类型，如int等，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。<br>所以，和C++一样，Java提供了基本数据类型，这种数据的变量不需要使用new创建，他们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。<br>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。<br>在Java SE5中，为了减少开发人员的工作，Java提供了自动拆箱与自动装箱功能。</p>
<p>自动装箱: 就是将基本数据类型自动转换成对应的包装类。</p>
<p>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</p>
<p>Integer i =10;  //自动装箱<br>int b= i;     //自动拆箱<br>Integer i=10 可以替代 Integer i = new Integer(10);，这就是因为Java帮我们提供了自动装箱的功能，不需要开发者手动去new一个Integer对象。<br>从上面反编译后的代码可以看出，int的自动装箱都是通过Integer.valueOf()方法来实现的，Integer的自动拆箱都是通过integer.intValue来实现的。</p>
<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><p>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。<br>深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。<br>•    浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>•    深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>
<p>Object 类提供的 clone 是只能实现 浅拷贝的。<br>如何实现深拷贝？<br>　　①、让每个引用类型属性内部都重写clone() 方法<br>　　②、利用序列化</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>1.泛型的定义：在程序中我们将一个对象放入集合中，但是集合不会记住对象的类型，当我们在次使用对象的时候，对象变为Object类型，而程序中还是原来的类型，我们必须要自己转换其类型，为了解决这个问题，则提出泛型。<br>2.泛型要求包容的是对象类型，而基本数据类型在Java中不属于对象。但是基本数据类型有其封装类，且为对象类型。<br>3.想放int类型，要放Integer类型不能直接放int（基本数据类型）。</p>
<p>限定通配符对类型进行了限制。有两种限定通配符，一种是<!--? extends T-->它通过确保类型必须是T的子类来设定类型的上界，另一种是<!--? super T-->它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<!--?-->表 示了非限定通配符，因为<!--?-->可以用任意类型来替代</p>
<p>由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现ArrayStoreException，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。Java不支持声明泛型数组，更确切地表达是：数组的类型不可以是类型变量，除非是采用通配符的方式</p>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>1 阻塞I/O（blocking I/O）<br>2 非阻塞I/O （nonblocking I/O）<br>3 I/O复用(select 和poll) （I/O multiplexing）<br>4 信号驱动I/O （signal driven I/O (SIGIO)）<br>5 异步I/O （asynchronous I/O (the POSIX aio_functions)）<br>同步：<br>      所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</p>
<p>例如普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事<br>异步：<br>      异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。<br>     例如 ajax请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕<br>阻塞<br>     阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。<br>     有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。<br>非阻塞<br>      非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。<br>对象的阻塞模式和阻塞函数调用<br>对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状 态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</p>
<ol>
<li>同步，就是我调用一个功能，该功能没有结束前，我死等结果。</li>
<li>异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）</li>
<li>阻塞，      就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。</li>
<li>非阻塞，  就是调用我（函数），我（函数）立即返回，通过select通知调用者<br>同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！<br>阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200766861.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200766861.png" class="lazyload"></a><br>Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。<br>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。<br>Buffer读写数据一般遵循以下四个步骤：</li>
<li>写入数据到Buffer</li>
<li>调用flip()方法，flip方法将Buffer从写模式切换到读模式。</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或者compact()方法<br>当一个read操作发生时，它会经历两个阶段：</li>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)<br>阻塞IO：blocking IO的特点就是在IO执行的两个阶段都被block了。<br>非阻塞IO：nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。<br>多路复用IO：I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。<br>信号驱动IO：<br>异步IO：发完声明去做其他事了</li>
</ol>
<p>•  bio: 传统的Java I/O操作，同步且阻塞IO。<br>•  nio: JDK1.4开始支持，同步阻塞或同步非阻塞IO<br>•  aio(nio.2): JDK7开始支持，异步非阻塞IO<br>同步阻塞IO（JAVA BIO）：<br>   同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br>同步非阻塞IO(Java NIO)：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。<br>异步阻塞IO（Java NIO）：<br>   此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！<br>（Java AIO(NIO.2)）异步非阻塞IO:<br>   在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。<br>BIO、NIO、AIO适用场景分析:<br>    BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<br>    NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<br>    AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 </p>
<p>IO多路复用：<br>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。<br>select<br>int select (int n, fd_set <em>readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);<br>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。<br>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。<br>poll<br>int poll (struct pollfd *fds, unsigned int nfds, int timeout);<br>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。<br>struct pollfd {<br>    int fd; /</em> file descriptor <em>/<br>    short events; /</em> requested events to watch <em>/<br>    short revents; /</em> returned events witnessed */<br>};<br>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。<br>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：<br>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<br>epoll<br>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。epoll的优点：<br>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>      即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。<br>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。<br>　　ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。ET(edge-triggered)是高速工作方式，只支持no-block socket<br>epoll的优点主要是一下几个方面：</p>
<ol>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。<br>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。<br>select 有最大文件描述符的限制，只能监听到有几个文件描述符就绪了，得遍历所有文件描述符获取就绪的IO。<br>poll 没有最大文件描述符的限制，与select一样，只能监听到有几个文件描述符就绪了，得遍历所有文件描述符获取就绪的IO。<br>epoll 没有最大文件描述符的限制，它通过回调的机制，一旦某个文件描述符就绪了，迅速激活这个文件描述符，当进程下一次调用epoll_wait()的时候便得到通知。<br>所以，在有大量空闲连接的时候，epoll的效率要高很多。<br>BIO，Blocking IO，阻塞IO，它是Java的上古产品，自出生就有的东西（JDK 1.0）。<br>使用BIO则数据准备和数据从内核空间拷贝到用户空间两个阶段都是阻塞的。<br>BIO的使用方式非常简单，服务端接收到一个连接就启动一个线程来处理这个连接的所有请求。BIO最大的缺点就是浪费资源，只能处理少量的连接，线程数随着连接数线性增加，连接越多线程越多，直到抗不住。<br>NIO，New IO，JDK1.4开始支持，内部是基于多路复用的IO模型。使用NIO则多条连接的数据准备阶段会阻塞在select上，数据从内核空间拷贝到用户空间依然是阻塞的。<br>因为第一阶段并不是连接本身处于阻塞阶段，所以通常来说NIO也可以看作是同步非阻塞IO。NIO的使用方式就有点复杂了，但是一个线程就可以处理很多连接。<br>首先，需要注册一个ServerSocketChannel并把它注册到selector上并监听accept事件，然后accept到连接后会获取到SocketChannel，同样把SocketChannel也注册到selector上，但是监听的是read事件。<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200820070.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200820070.png" class="lazyload"></a><br>NIO最大的优点，就是一个线程就可以处理大量的连接，缺点是不适合处理阻塞性任务，因为阻塞性任务会把这个线程占有着，其它连接的请求将得不到及时处理。<br>AIO，Asynchronous IO，异步IO，JDK1.7开始支持，算是一种比较完美的IO，Windows下比较成熟，但Linux下还不太成熟。使用异步IO则会在请求时立即返回，并在数据已准备且已拷贝到用户空间后进行回调处理，两个阶段都不会阻塞。AIO的使用方式不算太复杂，默认会启一组线程来处理用户的请求，而且如果在处理阻塞性任务，还会自动增加新的线程来处理其它连接的任务。<br>首先，创建一个AsynchronousServerSocketChannel并调用其accept方法，这一步相当于监听了accept事件，在收到accept事件后会获取到AsynchronousSocketChannel，然后就可以在回调方法completed()里面读取数据了，当然也要继续监听accept事件。<br>AIO最大的优点，就是少量的线程就可以处理大量的连接，而且可以处理阻塞性任务，但不能大量阻塞，否则线程数量会膨胀。<br>BIO是面向流（Stream）编程的，流又分成InputStream和OutputStream，那么Channel和Stream有什么区别呢？<br>•    Channel可以同时支持读和写，而Stream只能支持单向的读或写（所以分成InputStream和OutputStream）<br>•    Channel支持异步读写，Stream通常只支持同步<br>•    Channel总是读向（read into）Buffer，或者写自（write from）Buffer（有点绕，以Channel为中心，从Channel中读出数据到Buffer，从Buffer中往Channel写入数据）<br>BIO组件：<br>Buffer用于与Channel交互时使用，通过上一章的学习我们知道，数据从Channel读取到Buffer，或者从Buffer写入Channel。<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200831680.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583200831680.png" class="lazyload"></a><br>Buffer本质上是一个内存块，可以向里面写入数据，或者从里面读取数据，在Java中它被包装成了Buffer对象，并提供了一系列的方法用于操作这个内存块。</li>
</ol>
<p>Selector通过不断轮询的方式同时监听多个Channel的事件，注意，这里是同时监听，一旦有Channel准备好了，它就会返回这些准备好了的Channel，交给处理线程去处理。<br>所以，在NIO编程中，通过Selector我们就实现了一个线程同时处理多个连接请求的目标，也可以一定程序降低服务器资源的消耗。</p>
<h1 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h1><p>重载（Overload）是让类以统一的方式处理不同类型数据的一种手段，实质表现就是多个具有不同的参数个数或者类型的同名函数（返回值类型可随意，不能以返回类型作为重载函数的区分标准）同时存在于同一个类中，是一个类中多态性的一种表现（调用方法时通过传递不同参数个数和参数类型来决定具体使用哪个方法的多态性）。<br>重写（Override）是父类与子类之间的多态性，实质是对父类的函数进行重新定义，如果在子类中定义某方法与其父类有相同的名称和参数则该方法被重写，不过子类函数的访问修饰权限不能小于父类的；若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用 super 关键字。<br>方法重载（overload）：<br>1.必须是同一个类<br>2方法名（也可以叫函数）一样<br>3参数类型不一样或参数数量不一样<br>方法的重写（override）两同两小一大原则：<br>方法名相同，参数类型相同<br>子类返回类型小于等于父类方法返回类型，<br>子类抛出异常小于等于父类方法抛出异常，<br>子类访问权限大于等于父类方法访问权限。 </p>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>类加载：获取全限定名定义此类的二进制字节流，静态存储结构转化为方法区的二进制字节流<br>验证：验证字节流符合虚拟机要求<br>准备:为类变量设置类变量初始值，方法区中<br>解析：符号引用替换为直接引用<br>初始化：真正执行java代码<br><a href="./images/1583200917090.png" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="./images/1583200917090.png" class="lazyload"></a><br>从哪个地方去加载.class文件<br>在这里进行一个简单的分类。例举了5个来源<br>（1）本地磁盘<br>（2）网上加载.class文件（Applet）<br>（3）从数据库中<br>（4）压缩文件中（ZAR，jar等）<br>（5）从其他文件生成的（JSP应用）<br>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。<br>Log4j</p>
<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>在linux操作系统中，JVM在用户空间下向内核空间发送read命令，并切换至内核态，内核向硬盘灯其他硬件设备读取对应的数据至内核缓冲当中，这里就产生了第一次数据拷贝；<br>    数据准备完毕之后，操作系统由内核态转到用户态，并将内核缓冲中的数据拷贝至用户空间的缓冲区当中，这里就产生了第二次数据拷贝；<br>    当数据拷贝完成之后，用户空间向内核发送write命令，并且换至内核态，将数据从用户空间拷贝到内核缓冲区，这里就产生了第三次数据拷贝，<br>    当数据拷贝完成之后，内核需要将数据从内核缓冲拷贝至socket缓冲区，并切换至用户态，这就产生了第四次数据拷贝；<br>    最后当socket缓冲数据完毕之后，会将数据拷贝至协议引擎，并发送至网络，这就产生了第五次数据拷贝；<br>而在当前的描述过程中可以看出，用户空间中的缓冲区仅仅作为了一个数据媒介，并没有发挥任何的作用，这样就造成了一些不必要的数据拷贝以及性能丢失，所以JVM利用操作系统的另一个底层命令，将不必要的操作进行优化。<br>    在linux操作系统中，JVM在用户空间下向内核空间发送sendfile命令，并且换至内核态，内核从硬件中读取数据至内核缓冲区，这就产生了第一次数据拷贝；<br>    当数据在内核空间准备完成之后，内核直接将数据拷贝至socket缓冲区，这就产生了第二次数据拷贝，并从内核态切换至用户态；<br>    当socket缓冲区的数据准备完成之后，将数据拷贝至协议引擎，并发送至网络，这就产生了第三次数据拷贝；<br>随着操作系统发展，人们发现，其实在内核中发生一次拷贝也是可以省略的，即（将内核缓冲区的数据拷贝至socket缓冲区），它只是将内核缓冲区的描述符写入socket缓冲区，而协议引擎中的数据通过内核缓冲区和socket缓冲区进行Gather操作，即完成数据的拷贝，这样就免去了一次数据拷贝，实现了真正意义上的零拷贝。</p>
<h1 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h1><p>Java是值传递<br>基本类型和引用类型的理解<br>Java中的数据类型分为两种为基本类型和引用类型。<br>1、基本类型的变量保存原始值，所以变量就是数据本身。<br>    常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。<br>2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。<br>    常见的引用类型：类类型，接口类型和数组。<br>二、值传递和引用传递的理解<br>1、值传递<br>    在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。<br>2、引用传递<br>    引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。<br>（1）基本数据类型传值，对形参的修改不会影响实参；<br>（2）引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象；<br>（3）String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。<br>Int类型调用方法无法正确改变值，使用Integer传参数可以正确调用方法，取得正确返回值。<br>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。<br>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</p>
<h1 id="This用法"><a href="#This用法" class="headerlink" title="This用法"></a>This用法</h1><p>指的是访问类中的成员变量，用来区分成员变量和局部变量（重名问题）<br>this.方法名称用来访问本类的成员方法this();访问本类的构造方法 ()中可以有参数的 如果有参数 就是调用指定的有参构造1.this() 不能使用在普通方法中 只能写在构造方法中2.必须是构造方法中的第一条语句<br>一、this关键字主要有三个应用：<br> (1)this调用本类中的属性，也就是类中的成员变量；<br> (2)this调用本类中的其他方法；<br> (3)this调用本类中的其他构造方法，调用时要放在构造方法的首行<br>this 可以代表任何对象，当 this 出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的只能是当前类的实例。只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，this 就代表谁。</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cqz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mega-cqz.github.io/2020/03/01/Java/">https://mega-cqz.github.io/2020/03/01/Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mega-cqz.github.io">世界で一番おひめさま</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java-%E9%9D%A2%E8%AF%95/">Java,面试    </a></div><div class="post_share"><div class="social-share" data-image="/img/Fate.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/01/JUC/"><img class="prev_cover lazyload" data-src="/img/Fate.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Java并发包</span></div></a></div><div class="next-post pull_right"><a href="/2020/03/01/netword/"><img class="next_cover lazyload" data-src="/img/Fate.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>计算机网络</span></div></a></div></nav></div></main><footer id="footer" style="background-image: url(/img/Fate.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Cqz</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/ClickShowText.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":350,"height":500},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>