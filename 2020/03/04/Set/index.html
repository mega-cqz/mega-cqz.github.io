<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Java集合类 | 世界で一番おひめさま</title><meta name="description" content="Java集合类"><meta name="keywords" content="Java,集合类"><meta name="author" content="Cqz"><meta name="copyright" content="Cqz"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java集合类"><meta name="twitter:description" content="Java集合类"><meta name="twitter:image" content="https://mega-cqz.github.io/img/Fate.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java集合类"><meta property="og:url" content="https://mega-cqz.github.io/2020/03/04/Set/"><meta property="og:site_name" content="世界で一番おひめさま"><meta property="og:description" content="Java集合类"><meta property="og:image" content="https://mega-cqz.github.io/img/Fate.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://mega-cqz.github.io/2020/03/04/Set/"><link rel="prev" title="设计模式" href="https://mega-cqz.github.io/2020/05/16/Design/"><link rel="next" title="特征工程" href="https://mega-cqz.github.io/2020/03/02/feature/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">世界で一番おひめさま</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/%E9%BB%84%E6%BC%AB%E8%80%81%E5%B8%88.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Collection"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Collection</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Set"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Set</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#HashSet"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">HashSet</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#LinkedHashSet"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">LinkedHashSet</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TreeSet"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">TreeSet</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#List"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">List</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ArrayList"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">ArrayList</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Vector"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">Vector</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#LinkedList"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">LinkedList</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Queue"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">Queue</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#priorityQueue"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">priorityQueue</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Map"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Map</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#HashMap"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">HashMap</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#结构"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#扩容"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">扩容</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#PUT方法："><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">PUT方法：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#treeifyBin方法"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">treeifyBin方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#resize-方法"><span class="toc_mobile_items-number">2.1.5.</span> <span class="toc_mobile_items-text">resize()方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#成环的原因："><span class="toc_mobile_items-number">2.1.6.</span> <span class="toc_mobile_items-text">成环的原因：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#面试"><span class="toc_mobile_items-number">2.1.7.</span> <span class="toc_mobile_items-text">面试</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#LinkedHashMap"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">LinkedHashMap</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TreeMap"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">TreeMap</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#HashTable"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">HashTable</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Fail-Fast"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Fail-Fast</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Collection"><span class="toc-number">1.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">1.1.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">1.1.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">1.1.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-number">1.1.3.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">1.2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">1.2.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-number">1.2.2.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">1.2.3.</span> <span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">1.3.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#priorityQueue"><span class="toc-number">1.3.1.</span> <span class="toc-text">priorityQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map"><span class="toc-number">2.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">2.1.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构"><span class="toc-number">2.1.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩容"><span class="toc-number">2.1.2.</span> <span class="toc-text">扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PUT方法："><span class="toc-number">2.1.3.</span> <span class="toc-text">PUT方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treeifyBin方法"><span class="toc-number">2.1.4.</span> <span class="toc-text">treeifyBin方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-方法"><span class="toc-number">2.1.5.</span> <span class="toc-text">resize()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成环的原因："><span class="toc-number">2.1.6.</span> <span class="toc-text">成环的原因：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试"><span class="toc-number">2.1.7.</span> <span class="toc-text">面试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">2.2.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-number">2.3.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashTable"><span class="toc-number">3.</span> <span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fail-Fast"><span class="toc-number">4.</span> <span class="toc-text">Fail-Fast</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/Fate.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Java集合类</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-03-04<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-05</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>继承了AbstractSet抽象类，和ArrayList和LinkedList一样，在他们的抽象父类中，都提供了equals（）方法和hashCode（）方法。它们自身并不实现这两个方法，（但是ArrayList和LinkedList的equals（）实现不同。这就意味着诸如和HashSet一样继承自AbstractSet抽象类的TreeSet、LinkedHashSet等，他们只要元素的个数和集合中元素相同，即使他们是AbstractSet不同的子类，他们equals（）相互比较的后的结果仍然是true。<br>从JDK源码可以看出，底层并没有使用我们常规认为的利用hashcode（）方法求的值进行比较，而是通过调用AbstractCollection的containsAll（）方法，如果他们中元素完全相同（与顺序无关），则他们的equals（）方法的比较结果就为true。<br>HashSet内部通过使用HashMap的键来存储集合中的元素，而且内部的HashMap的所有值<br>都是null。（因为在为HashSet添加元素的时候，内部HashMap的值都是PRESENT），而PRESENT在实例域的地方直接初始化了，而且不允许改变。</p>
<p>添加元素<br>直接调用HashMap的put()方法，把元素本身作为key，把PRESENT作为value，也就是这个map中所有的value都是一样的。<br>（1）HashSet内部使用HashMap的key存储元素，以此来保证元素不重复；<br>（2）HashSet是无序的，因为HashMap的key是无序的；<br>（3）HashSet中允许有一个null元素，因为HashMap允许key为null；<br>（4）HashSet是非线程安全的；<br>（5）HashSet是没有get()方法的；</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet是不支持按访问顺序对元素排序的，只能按插入顺序排序。<br>（1）LinkedHashSet的底层使用LinkedHashMap存储元素。<br>（2）LinkedHashSet是有序的，它是按照插入的顺序排序的。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>(01)TreeSet实际上是TreeMap实现的。当我们构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。<br>(02) TreeSet是非线程安全的。<br>(03) TreeSet实现java.io.Serializable的方式。当写入到输出流时，依次写入“比较器、容量、全部元素”；当读出输入流时，再依次读取。<br>（1）TreeSet底层使用NavigableMap存储元素；<br>（2）TreeSet是有序的；<br>（3）TreeSet是非线程安全的；<br>（4）TreeSet实现了NavigableSet接口，而NavigableSet继承自SortedSet接口；<br>（5）TreeSet实现了SortedSet接口；（彤哥年轻的时候面试被问过TreeSet和SortedSet的区别^^）</p>
<p>（1）通过之前的学习，我们知道TreeSet和LinkedHashSet都是有序的，那它们有何不同？<br>LinkedHashSet并没有实现SortedSet接口，它的有序性主要依赖于LinkedHashMap的有序性，所以它的有序性是指按照插入顺序保证的有序性；<br>而TreeSet实现了SortedSet接口，它的有序性主要依赖于NavigableMap的有序性，而NavigableMap又继承自SortedMap，这个接口的有序性是指按照key的自然排序保证的有序性，而key的自然排序又有两种实现方式，一种是key实现Comparable接口，一种是构造方法传入Comparator比较器。<br>(01)    TreeSet里面实际上是使用的NavigableMap（接口）来存储元素</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>默认容量10<br>动态扩容的基本思路：<br>计算出当前数组的大小，以当前的大小的1.5倍（即上图中的newCapacity）作为扩容后的大小<br>判断newCapacity和传入的最小容量需求minCapacity，如果newCapacity<mincapacity，这直接把mincapacity赋值给newcapacity<br>检查赋值后的newCapacity是否超过int的最大值（这里用是否小于0来判断是否溢出，溢出直接抛出异常），否则在int的最大值和MAX_ARRAY_SIZE中取较小的值作为最终的newCapacity<br>调用Arrays.copyOf方法，把原始数据复制到扩容的数组</mincapacity，这直接把mincapacity赋值给newcapacity<br></p>
<p>（1）ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容；<br>（2）ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)；<br>（3）ArrayList添加元素到尾部极快，平均时间复杂度为O(1)；<br>（4）ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)；<br>（5）ArrayList从尾部删除元素极快，时间复杂度为O(1)；<br>（6）ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)；<br>（7）ArrayList支持求并集，调用addAll(Collection<!--? extends E--> c)方法即可；<br>（8）ArrayList支持求交集，调用retainAll(Collection<!--? extends E--> c)方法即可；<br>（7）ArrayList支持求单向差集，调用removeAll(Collection<!--? extends E--> c)方法即可；</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>synchronized 底层是通过使用对象的监视器锁（monitor）来确保同一时刻只有一个线程执行被修饰的方法或者代码块。可以用锁和钥匙来解释，被 synchronized 修饰的方法或者代码块是一把锁，这把锁是归对象所有的，当一个线程需要执行这些方法或者代码块的时候，锁就被钥匙插上了，所以其他线程就不能执行这些方法或者代码块。<br>•  Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；<br>•  Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。<br>1、Vector是使用数组保存数据，和ArrayList套路一样<br>2、如果每有指定构造Vector那么它的默认容量位 10 增长系数位 0<br>3、扩容机制：如果增长系数不位 0 那么就是当前容量  + 增长系数，否则就的当前容量加一倍 更详细的化还是看看上面的ensureCapacity（）函数，最的扩容量是Integer.MAX_VALUE<br>4、Vector的克隆函数，即是将全部元素克隆到一个数组中。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 是双向列表，链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。<br>　　ArrayList基于数组， LinkedList基于双向链表，对于随机访问， ArrayList比较占优势，但LinkedList插入、删除元素比较快，因为只要调整指针的指向。针对特定位置需要遍历时，所以LinkedList在随机访问元素的话比较慢。<br>　　LinkedList没有实现自己的 Iterator，使用的是 ListIterator。<br>　　LinkedList需要更多的内存，因为 ArrayList的每个索引的位置是实际的数据，而 LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。<br>　　LinkedList也是非线程安全的，只有在单线程下才可以使用。为了防止非同步访问，Collections类里面提供了synchronizedList()方法。<br>（1）LinkedList是一个以双链表实现的List；<br>（2）LinkedList还是一个双端队列，具有队列、双端队列、栈的特性；<br>（3）LinkedList在队列首尾添加、删除元素非常高效，时间复杂度为O(1)；<br>（4）LinkedList在中间添加、删除元素比较低效，时间复杂度为O(n)；<br>（5）LinkedList不支持随机访问，所以访问非队列首尾的元素比较低效；<br>（6）LinkedList在功能上等于ArrayList + ArrayDeque；</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="priorityQueue"><a href="#priorityQueue" class="headerlink" title="priorityQueue"></a>priorityQueue</h3><p>数组<br>PriorityQueue：优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，类似于C++的仿函数）。<br>Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现。<br>（1）PriorityQueue是一个小顶堆；<br>（2）PriorityQueue是非线程安全的；<br>（3）PriorityQueue不是有序的，只有堆顶存储着最小的元素；<br>（4）入队就是堆的插入元素的实现；<br>（5）出队就是堆的删除元素的实现；</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583307661744.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583307661744.png" class="lazyload"></a></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>map的put方法的时间复杂度为O（1），get方法的时间复杂度为O(1)~ O(n)。<br>HashMap是基于哈希表的Map接口的非同步实现。实现HashMap对数据的操作，允许有一个null键，多个null值。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>   HashMap底层就是一个数组结构，数组中的每一项又是一个链表。数组+链表结构，新建一个HashMap的时候，就会初始化一个数组。Entry就是数组中的元素，每个Entry其实就是一个key-value的键值对，它持有一个指向下一个元素的引用，这就构成了链表，HashMap底层将key-value当成一个整体来处理，这个整体就是一个Entry对象。HashMap底层采用一个Entry【】数组来保存所有的key-value键值对，当需要存储一个Entry对象时，会根据hash算法来决定在其数组中的位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry对象时，也会根据hash算法找到其在数组中的存储位置， 在根据equals方法从该位置上的链表中取出Entry;</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>HashMap扩容条件1)数组的长度达到了扩容阀值,2)桶中的链表长度达到了8,并且数组的长度小于64<br>树化的条件是：桶中单链表的长度达到了8,并且整个数组的长度大于等于64，否则直接扩容，小于6时反树化<br>     HashMap在添加值的时候，它默认能存储16个键值对，直到你使用这个HashMap时，它才会给HashMap分配16个键值对的存储空间，（负载因子为0.75,新阈值为12），当16个键值对已经存储满了，我们在添加第17个键值对的时候才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。<br>HashMap也有可能存储更多的键值对，最多可以存储26个键值对，我们来算一下：存储的前11个值全部发生hash碰撞，存到数组的同一个位置中，（这时元素个数小于阈值12，不会扩容），之后存入15个值全部分散到数组剩下的15个位置中，（这时元素个数大于等于阈值，但是每次存入元素并没有发生hash碰撞，不会扩容），11+15=26，当我们存入第27个值得时候满足以上两个条件，HashMap才会发生扩容；<br>hashMap  会根据  当前的hashMap 的存储量达到 16<em>0.75=12 的时候，就是扩容  16</em>2=32  依次类推下去。2倍扩容。<br>first = tab[(n - 1) & hash])。<br>使用数组长度减一 与运算 hash 值。这行代码就是为什么要让前面的 hash 方法移位并异或。<br>我们分析一下：<br>首先，假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000。<br>如果数组长度是16，也就是 15 与运算这两个数， 你会发现结果都是0。这样的散列结果太让人失望了。很明显不是一个好的散列算法。<br>但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。<br>总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000 和 1000000000100000000000000 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。<br>我们一定要保证 & 中的二进制位全为 1，才能最大限度的利用 hash 值，并更好的散列，只有全是1 ，才能有更多的散列结果。如果是 1010，有的散列结果是永远都不会出现的，比如 0111，0101，1111，1110…，只要 & 之前的数有 0， 对应的 1 肯定就不会出现（因为只有都是1才会为1）。大大限制了散列的范围<br>简单翻译一下就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素个数和概率的对照表。<br>从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p>
<h3 id="PUT方法："><a href="#PUT方法：" class="headerlink" title="PUT方法："></a>PUT方法：</h3><p>判断数组是否为空，如果是空，则创建默认长度位 16 的数组。<br>通过与运算计算对应 hash 值的下标，如果对应下标的位置没有元素，则直接创建一个。<br>如果有元素，说明 hash 冲突了，则再次进行 3 种判断。<br>    判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。<br>    如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。<br>    如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。<br>最后，如果这三个判断返回的 e 不为null，则说明key重复，则更新key对应的value的值。<br>对维护着迭代器的modCount 变量加一。<br>最后判断，如果当前数组的长度已经大于阀值了。则重新hash。</p>
<h3 id="treeifyBin方法"><a href="#treeifyBin方法" class="headerlink" title="treeifyBin方法"></a>treeifyBin方法</h3><p>在链表的循环中，有一个方法 treeifyBin，这个方法在链表长度大于等于8 的时候会调用该方法虽然主要功能是替换链表结构为红黑树，但是在替换前，会先判断，如果数组是 null 或者数组的长度小于 64，则重新散列，因为重新散列会拆分链表，使得链表的长度变短。提高性能。如果长度大于64了。就只能将链表变为红黑树了。<br>首先得到数组的长度,如果数组的长度小于MIN_TREEIFY_CAPACITY,那么就直接进行扩容操作,而不是进行树化,所以这里我们可以知道我们来看else if,这里面同样是一个while循环,判读语句中拿到链表的头结点,因为树节点TreeNode继承于HashMap.Node,所以这里边先将链表的头结点e转化为一个树节点p,然后开始遍历头结点,开始给各个树节点添加前后节点的引用(看起来更像是一样双链表),桶内的树节点全部添加为前后引用之后,真正的树化就要开始了：<br>treeify的入参为需要被树化的链表的头结点所转换为的树节点,然后开始一个for循环,条件为x != null,next则为每次循环x的下一节点引用<br>先说一下红黑树的五个性质:<br>•    每个结点要么是红的，要么是黑的。<br>•    根结点是黑的。<br>•    每个叶结点，即空结点（NIL）是黑的。<br>•    父节点和子节点都不能同时是红色的，即：不能有两个连续的红色节点<br>•    对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。<br>关于红黑树可以看我这篇文章 TreeMap 源码分析<br>继续往下说,循环内:<br>首先得到x的下一节点并赋值给next,并初始化当前节点x的左右子叶节点,第一遍循环root节点肯定是为空的,所以将x节点设置为根节点root,并将其父节点设置为null,颜色设置为黑色,这是第一次循环,第二次循环,进入到了else语句中,首先获取到当前节点的key值和hash值，下面是一个死循环：<br>在死循环内首先得到根节点,并将根节点的hash值和当前节点的hash值做对比,如果比根节点大则在根节点的右子树上,比 根节点小则在左子树上,红黑树中,左子树总比右子树要小,然后依次遍历-对比判断 最后将当前节点放到合适的树节点的左右子树中。<br>遍历整个红黑树并将当前节点放入到指定合适的左右子树中,因为我们还没有为当且插入的节点进行着色操作,所以需要通过balanceInsertion进行着色,基于红黑树的五个特性我们在插入一个树节点并且为其着色之后,可能需要重新调整红黑树,为什么呢,其他的不说,开始我们自发的将单链表的头结点设置为了根节点,如果单链表的其他节点均小于头结点,那么在树中的表现为,根节点的左子树很深,而右子树则没有,红黑树是一种平衡树,根据第五条特性可以看出,所以需要对红黑树进行调整,同样需要balanceInsertion来操作。<br>入参为根节点和当前节点,首先设置当前节点是红色,里面是一个for循环,先看循环中的第一个判读体如果当前树节点的父子树节点为空,因为当前节点已在红黑树中,那么只有一种可能,当前节点是父节点,颜色着色为黑色,并返回当前节点,<br>如果当前节点的父节点是黑色,并当前节点的祖父节点为空,所以当前节点是根节点的子树节点,所以不需要调整红黑树,直接返回就行<br>所以上面的判断是祛除当前节点是根节点或者当前节点是根节点的子树节点的情况,如果根节点只有一个子树节点,那么此时的红黑树违反第五条特性,但是怎么调整都是这样,就会陷入一个死循环中,所以排除了这种情况.<br>通过上面的判断,可以知晓循环体中的变量的意义:<br>xp当前节点的父节点<br>xpp当前节点的父节点的父节点,即祖父节点<br>xppl当前节点的祖父节点的左子树节点 即当前节点的叔父节点<br>xppr 当前节点的祖父节点的右子树节点 即当前节点的叔父节点<br>首先要确定一点就是,能进入当前循环的都是父节点是红色的,如果是黑色的,在上个判断 体中的else中就拦截掉了,看当前的判断判断条件是如果xp是xpp的左子树节点,即xppl,然后进入下一个判断<br>如果当前节点的叔父节点xppr不为空,并且颜色为红色,那么就进行如下设置:叔父节点xppr设置为黑色,xp设置为黑色,xpp设置为红色,然后将祖父节点xpp设置为当前节点,进行下一次的遍历循环,开始判断祖父节点变为红色之后是否合乎红黑树的特性,如果祖父节点的父节点是黑色的话,那就没有异常,直接返回根节点即可,如果祖父节点的父节点是红色,因为祖父节点也是红色的,违反了第四个特性,需要对红黑树进行调整,下面就涉及到了红黑树的左右旋的操作,限于篇幅这里就不过多介绍了,<br>如果xp == xppl,xp.color = red<br>如果xppr.color == red,那么xpp.color != red, 则设置xpp.color == red并且xppl,xppr != red;<br>如果xppr.color != red<br>•    如果当前节点为父节点的右子树节点,左旋父节点,使父节点位于当前节点的左子树上,然后将父节点作为当前节点进行如下处理：<br>设置当前节点的父节点的颜色为黑色,祖父节点为红色,右旋祖父节点<br>•    如果当前节点为父节点的左子树节点:<br>设置当前节点的父节点的颜色为黑色,祖父节点为红色,右旋祖父节点<br>如果父节点位于祖父节点的右子树上,道理是一样的.<br>回到treeify,树化完成之后还有最后一步moveRootToFront,因为HashMap中的红黑树是与双链表糅合在一起的,具体表现为,数组table获取当前下标的节点,是链表的头结点,单不一定是树的根节点,因此需要将树的根节点与链表的头结点设置为同一个</p>
<h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h3><p>该方法可以说还是比较复杂的。初始的时候也是调用的这个方法，当链表数超过8的时候同时数组长度小于64的时候也是调用的这个方法。该方法步骤如下：<br>    If{判断容量是否大于0，如果大于0，并且容量已将大于最大值，则设置阀值为 int 最大值，并返回，如果老的容量乘以 2 小于最大容量，且老的容量大于等于16，则更新阀值。也就是乘以2.}<br>    Else if{如果老的阀值大于0，则新的容量等于老的阀值。注意：这里很重要。还记的我们之前使用new 操作符的时候，会设置阀值为 2 的幂次方，那么这里就用上了那个计算出来的数字，也就是说，就算我们设置的不是2的幂次方，HashMap 也会自动将你的容量设置为2的幂次方。}<br>   Else{ 如果老的阀值和容量都不大于0，则认为是一个新的数组，默认初始容量为16，阀值为 16 * 0.75f，也就是 12。}<br>   If{ 如果，新的阀值还是0，那么就使用我们刚刚设置的容量（HashMap 帮我们算的），通过乘以 0.75，得到一个阀值，然后判断算出的阀值是否合法：如果容量小于最大容量并且阀值小于最大容量，那么则使用该阀值，否则使用 int 最大值。}<br>    将刚刚的阀值设置打当前Map实例的阀值属性中。<br>    将刚刚的数组设置到当前Map实例的数组属性中。<br>如果老的数组不是null，则将老数组中的值重新散列到新数组中。如果是null，直接返回新数组。<br>创建一个新容量的桶；<br>（5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；</p>
<p>重新散列：<br>    首先循环老数组。下标从0开始，如果对应下标的值不是null，则判断该值有没有next 节点，也就是判断是否是链表。<br>    如果不是链表，则根据新的数组长度重新hash该元素。<br>    如果该节点是树，则调用红黑树的 split 方法，传入当前对象和新数组还有下标，该方法会重新计算红黑树中的每个hash值，如果重新计算后，树中元素的hash值不同，则重新散列到不同的下标中。达到拆分红黑树的目的，提高性能。具体如何拆分下面再说。<br>    之后的判断就是链表，在Java8中，该部分代码不是简单的将旧链表中的数据拷贝到新数组中的链表就完了，而是会对旧的链表进行重新 hash，如果 hash 得到的值和之前不同，则会从旧的链表中拆出，放到另一个下标中去，提高性能，刚刚的红黑树也是这么做的。<br>这里的重新hash 不是使用的 [e.hash & (newCap - 1)] 方法，而是使用更加效率的方法，直接 hash 老的数组容量，就没有了减一的操作，可见 JDK 的作者为了性能可以说是无所不用其极了。</p>
<h3 id="成环的原因："><a href="#成环的原因：" class="headerlink" title="成环的原因："></a>成环的原因：</h3><p>先将A复制到新的hash表中，然后接着复制B到链头（A的前边：B.next=A），本来B.next=null，到此也就结束了（跟线程二一样的过程），但是，由于线程二扩容的原因，将B.next=A，所以，这里继续复制A，让A.next=B，由此，环形链表出现：B.next=A; A.next=B<br>解释一下transfer的过程：<br>首先获取新表的长度，之后遍历新表的每一个entry，然后每个ertry中的链表，以反转的形式，形成rehash之后的链表。<br>并发问题：<br>若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。</p>
<p>存数据的时间复杂度是O(1),因为只需要首先根据Key计算哈希值，其实就是数组的下标，找到存放的位置，然后把key-value链表节点链接上去就OK了。<br>取数据的时间复杂度最好是O(1)，最差是O(n),为什么呢？因为如果根据key首先得到哈希地址，发现该下标处位置已经被占用，那么我们要找的节点到底在链表的哪个位置，如果该位置就只有一个节点或者要找的节点就在表头，那么就不用再往后遍历链表了，所以最好情况下时间复杂度是O(1)；如果要找到的节点在链表表尾，那么就需要一个一个遍历链表，所以此时最差情况下为O(n)。但是如果我们的链表长度都很短，那么时间效率就会很高，其实即使是O（n）这个级别的复杂度正常也还是可以接受的。所以来总结一下，map的put方法的时间复杂度为O（1），get方法的时间复杂度为O(1)~ O(n)。<br>那么containKey()方法的时间复杂度呢，其实和get方法的时间复杂度是一样的，也是O(1)~O(n)，首先我们也是要根据key计算出对应的哈希地址，如果该地址处没有占用，那么可以直接返回false，说明Map中没有这个key；如果已经被占用，那就开始在链表上遍历Entry，比较key,所以这和刚才的get方法是一样的，从原理上就是一样的，那么时间复杂度自然也是一样的。<br>containValue()的时间复杂度和containKey()的时间复杂度不是一个级别的，因为他要依赖于key,所以他的时间复杂度为O(n).</p>
<p>总结<br>（1）HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；<br>（2）HashMap的默认初始容量为16（1<<4），默认装载因子为0.75f，容量总是2的n次方；<br>（3）HashMap扩容时每次容量变为原来的两倍；<br>（4）当桶的数量小于64时不会进行树化，只会扩容；<br>（5）当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；<br>（6）当单个桶中元素数量小于6时，进行反树化；<br>（7）HashMap是非线程安全的容器；<br>（8）HashMap查找添加元素的时间复杂度都为O(1)；</p>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>树化条件8：<br>当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值（树华门槛）。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是拍拍屁股决定的，而是根据概率统计决定的。</p>
<p>扩容时需不需要全Hash<br>假如现在容量为初始容量16，再假如5，21，37，53的hash自己（二进制），<br>所以在oldTab中的存储位置就都是 hash & （16 - 1）【16-1就是二进制1111，就是取最后四位】，<br>5 ：00000101<br>21：00010101<br>37：00100101<br>53：00110101<br>四个数与（16-1）相与后都是0101<br>即原始链为：5—>21—>37—>53—->null<br>此时进入代码中 do-while 循环，对链表节点进行遍历，判断是留下还是去新的链表：<br>lo就是扩容后仍然在原地的元素链表<br>hi就是扩容后下标为 原位置+原数组容量 的元素链表，从而不需要重新计算hash。<br>因为扩容后计算存储位置就是 hash & （32 - 1）【取后5位】，但是并不需要再计算一次位置，<br>此处只需要判断左边新增的那一位（右数第5位）是否为1即可判断此节点是留在原地lo还是移动去高位hi：(e.hash & oldCap) == 0 （oldCap是16也就是10000，相与即取新的那一位）<br>5 ：00000101——————》0留在原地 lo链表<br>21：00010101——————》1移向高位 hi链表<br>37：00100101——————》0留在原地 lo链表<br>53：00110101——————》1移向高位 hi链表<br>为什么为0就放在原位置，为1就要放到原位置+原数组容量位置呢<br>因为上面进行resize的时候，是将数组容量扩大了一倍，原计算位置取模的时候是通过length-1，那么现在与oldCap相与后，如果右边第5位是1，那就是增加了一个原数组的长度(因为原取模的时候是取4位)，所以如果右边第5位要是1的话，那新的位置就是原位置+原数组容量。<br>所以在1.8的情况先，resize是不需要对原数组链表中的所有节点都进行再次hash，移动之后的节点也的顺序也不会改变，而且在一定程度上也避免了1.7中死锁的发生。</p>
<p>两次hash<br>这样做有两个好处，我来简单解释一下。我们再看一下上面求余的计算图，图中的 hash 是由键的 hashCode 产生。计算余数时，由于 n 比较小，hash 只有低4位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以上图中的 hash 高4位数据与低4位数据进行异或运算，即 hash ^ (hash >>> 4)。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。此时的计算过程如下：<br><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583307700081.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583307700081.png" class="lazyload"></a><br>在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前16位为高位，后16位为低位，所以要右移16位。<br>上面所说的是重新计算 hash 的一个好处，除此之外，重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因了。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>afterNodeInsertion(boolean evict)方法<br>（1）如果evict为true，且头节点不为空，且确定移除最老的元素，那么就调用HashMap.removeNode()把头节点移除（这里的头节点是双向链表的头节点，而不是某个桶中的第一个元素）；<br>（2）HashMap.removeNode()从HashMap中把这个节点移除之后，会调用afterNodeRemoval()方法；<br>（3）afterNodeRemoval()方法在LinkedHashMap中也有实现，用来在移除元素后修改双向链表，见下文；<br>（4）默认removeEldestEntry()方法返回false，也就是不删除元素。<br>（1）LinkedHashMap继承自HashMap，具有HashMap的所有特性；<br>（2）LinkedHashMap内部维护了一个双向链表存储所有的元素；<br>内部全部元素做成链表，插入顺序<br>（3）如果accessOrder为false，则可以按插入元素的顺序遍历元素；<br>（4）如果accessOrder为true，则可以按访问元素的顺序遍历元素；<br>（5）LinkedHashMap的实现非常精妙，很多方法都是在HashMap中留的钩子（Hook），直接实现这些Hook就可以实现对应的功能了，并不需要再重写put()等方法；<br>（6）默认的LinkedHashMap并不会移除旧元素，如果需要移除旧元素，则需要重写removeEldestEntry()方法设定移除策略；<br>（7）LinkedHashMap可以用来实现LRU缓存淘汰策略；</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap使用红黑树存储元素，可以保证元素按key值的大小进行遍历。<br>TreeMap实现了Map、SortedMap、NavigableMap、Cloneable、Serializable等接口。<br>SortedMap规定了元素可以按key的大小来遍历，它定义了一些返回部分map的方法。<br>NavigableMap是对SortedMap的增强，定义了一些返回离目标key最近的元素的方法。<br>插入再平衡<br>插入的元素默认都是红色，因为插入红色元素只违背了第4条特性，那么我们只要根据这个特性来平衡就容易多了。<br>根据不同的情况有以下几种处理方式：</p>
<ol>
<li>插入的元素如果是根节点，则直接涂成黑色即可，不用平衡；</li>
<li>插入的元素的父节点如果为黑色，不需要平衡；</li>
<li>插入的元素的父节点如果为红色，则违背了特性4，需要平衡，平衡时又分成下面三种情况：</li>
</ol>
<p><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583307905275.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583307905275.png" class="lazyload"></a></p>
<p><a href="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583307918474.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="enter description here" class="fancybox"><img alt="enter description here" title="enter description here" data-src="https://raw.githubusercontent.com/mega-cqz/xiaoshujiang/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1583307918474.png" class="lazyload"></a></p>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>extends Dictionary    没红黑树<br>1.Hashtable的默认容量为11，默认负载因子为0.75.(HashMap默认容量为16，默认负载因子也是0.75)<br>2.Hashtable的容量可以为任意整数，最小值为1，而HashMap的容量始终为2的n次方。<br>3.为避免扩容带来的性能问题，建议指定合理容量。<br>4.跟HashMap一样，Hashtable内部也有一个静态类叫Entry，其实是个键值对对象，保存了键和值的引用。<br>5.HashMap和Hashtable存储的是键值对对象，而不是单独的键或值。<br>jdk1.8的hashMap的put方法的过程，Hashtable和其类似，基本上“计算索引，逻辑判断”这个部分是一致的，差别在于Hashtable中没有用到红黑树。<br>HashMap和Hashtable的区别<br>    HashMap是非线程安全的，Hashtable是线程安全的，所以Hashtable重量级一些，因为使用了synchronized关键字来保证线程安全。<br>    HashMap允许key和value都为null，而Hashtable都不能为null。<br>    Hashtable继承自 JDK 1.0 的 Dictionary 虚拟类，而HashMap是 JDK 1.2 引进的 Map 接口的一个实现。<br>    Hashtable和HashMap扩容的方法不一样，Hashtable中数组默认大小11，扩容方式是 old*2+1。HashMap中数组的默认大小是16，而且一定是2的指数，增加为原来的2倍。<br>    两者通过hash值散列到hash表的算法不一样，Hashtable是古老的除留余数法，直接使用Object的hashcode，而后者是强制容量为2的幂，重新根据hashcode计算hash值，在使用hash和（hash表长度 – 1）进行与运算，也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。<br>    HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。以下面测试case为例： </p>
<h1 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h1><p>fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug<br>什么是fail-fast？<br>fail-fast机制是java集合中的一种错误机制。<br>当使用迭代器迭代时，如果发现集合有修改，则快速失败做出响应，抛出ConcurrentModificationException异常。<br>这种修改有可能是其它线程的修改，也有可能是当前线程自己的修改导致的，比如迭代的过程中直接调用remove()删除元素等。<br>另外，并不是java中所有的集合都有fail-fast的机制。比如，像最终一致性的ConcurrentHashMap、CopyOnWriterArrayList等都是没有fast-fail的。<br>那么，fail-fast是怎么实现的呢？<br>细心的同学可能会发现，像ArrayList、HashMap中都有一个属性叫modCount，每次对集合的修改这个值都会加1，在遍历前记录这个值到expectedModCount中，遍历中检查两者是否一致，如果出现不一致就说明有修改，则抛出ConcurrentModificationException异常。<br>modCount，修改次数，有这个属性表示PriorityQueue也是fast-fail的；</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cqz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mega-cqz.github.io/2020/03/04/Set/">https://mega-cqz.github.io/2020/03/04/Set/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mega-cqz.github.io">世界で一番おひめさま</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java-%E9%9B%86%E5%90%88%E7%B1%BB/">Java,集合类    </a></div><div class="post_share"><div class="social-share" data-image="/img/Fate.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/16/Design/"><img class="prev_cover lazyload" data-src="/img/Fate.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>设计模式</span></div></a></div><div class="next-post pull_right"><a href="/2020/03/02/feature/"><img class="next_cover lazyload" data-src="/img/Fate.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>特征工程</span></div></a></div></nav></div></main><footer id="footer" style="background-image: url(/img/Fate.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Cqz</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/ClickShowText.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":350,"height":500},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>